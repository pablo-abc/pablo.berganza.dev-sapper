<!doctype html> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <link href=apple-icon-57x57.png rel=apple-touch-icon sizes=57x57> <link href=apple-icon-60x60.png rel=apple-touch-icon sizes=60x60> <link href=apple-icon-72x72.png rel=apple-touch-icon sizes=72x72> <link href=apple-icon-76x76.png rel=apple-touch-icon sizes=76x76> <link href=apple-icon-114x114.png rel=apple-touch-icon sizes=114x114> <link href=apple-icon-120x120.png rel=apple-touch-icon sizes=120x120> <link href=apple-icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=apple-icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=apple-icon-180x180.png rel=apple-touch-icon sizes=180x180> <link href=android-icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=favicon-32x32.png rel=icon sizes=32x32 type=image/png> <link href=favicon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=favicon-16x16.png rel=icon sizes=16x16 type=image/png> <link href=manifest.json rel=manifest> <meta content=#E34495 name=msapplication-TileColor> <meta content=ms-icon-144x144.png name=msapplication-TileImage> <meta content=#E34495 name=theme-color> <base href=/ > <link href="https://fonts.googleapis.com/css2?family=Overpass:wght@400;600;700&family=Roboto+Slab:wght@400;600;700&display=swap" rel=stylesheet> <link href=dracula.css rel=stylesheet> <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.ico rel=icon type=image/png> <script src=https://unpkg.com/yt-vid@0.0.5/dist/yt-vid/yt-vid.esm.js type=module></script> <script src=https://unpkg.com/yt-vid@0.0.5/dist/yt-vid/yt-vid.js nomodule=""></script> <link href=client/main.1857510773.css rel=stylesheet><link href=client/client.a9a415dd.css rel=stylesheet><link href=client/Commento.3cba96ec.css rel=stylesheet><link href=client/Blog.25e2fa42.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>GraphQL: Is it worth the switch? | Pablo Berganza</title><meta content="Pablo Berganza" name=author><meta content="A nice alternative to REST APIs with a fantastic developer experience" name=description><meta content="GraphQL: Is it worth the switch? | Pablo Berganza" itemprop=name><meta content="A nice alternative to REST APIs with a fantastic developer experience" itemprop=description><meta content=https://pablo.berganza.dev/img/blog-pics/2019-06-11-800.jpg name=twitter:image> <meta content=https://pablo.berganza.dev/img/blog-pics/2019-06-11-800.jpg property=og:image> <meta content=https://pablo.berganza.dev/img/blog-pics/2019-06-11-800.jpg itemprop=image> <meta content=summary_large_image name=twitter:card><meta content="GraphQL: Is it worth the switch? | Pablo Berganza" name=twitter:title><meta content="A nice alternative to REST APIs with a fantastic developer experience" name=twitter:description><meta content=Pablo_ABC name=twitter:site><meta content=Pablo_ABC name=twitter:creator><meta content="GraphQL: Is it worth the switch? | Pablo Berganza" property=og:title><meta content=https://pablo.berganza.dev/blog/graphql-is-it-worth-the-switch property=og:url><meta content="Pablo Berganza" property=og:site_name><meta content="A nice alternative to REST APIs with a fantastic developer experience" property=og:description><meta content=en property=og:locale><meta content=1441268341 property=fb:admins><meta content=2097322913669232 property=fb:app_id><meta content=article property=og:type><meta content="Pablo Berganza" property=article:author> <meta content=2019-06-11 property=article:published_time> <meta name=twitter:label1 value="Reading time"> <meta name=twitter:label2 value=Author> <meta name=twitter:data1 value="10 min"> <meta name=twitter:data2 value="Pablo Berganza"><script type=application/ld+json>{
        "@context": "https://schema.org/",
        "@type": "BlogPosting",
        "isFamilyFriendly": "true",
        "author": {
          "@type": "Person",
          "name": "Pablo Berganza",
          "url": "https://pablo.berganza.dev"
        }
      } </script><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <header class=svelte-omxq6j><nav class=svelte-199w0oq><div class="svelte-199w0oq left-nav"><a href=./ class=svelte-199w0oq id=logo><span class=svelte-199w0oq>Pablo</span> <span class=svelte-199w0oq>Berganza</span></a> <div class="svelte-199w0oq nav-items"><a href=blog rel=prefetch class="svelte-199w0oq nav-item" id=blog-nav><span class=svelte-199w0oq>Blog</span> </a><a href=contact class="svelte-199w0oq nav-item" id=contact-nav><span class=svelte-199w0oq>Contact Me</span> </a></div></div> <div class="svelte-199w0oq right-nav"><a href=es/blog/graphql-is-it-worth-the-switch rel=prefetch>es</a> <a href=https://github.com/pablo-abc rel="noopener noreferrer" target=_blank title=GitHub aria-label=GitHub class="nav-item sm svelte-ql1677"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 496 512" xmlns=http://www.w3.org/2000/svg><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" fill=currentColor></path></svg> </a> <a href=https://www.instagram.com/berganzapablo/ rel="noopener noreferrer" target=_blank title=Instagram aria-label=Instagram class="nav-item sm svelte-ql1677"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z" fill=currentColor></path></svg> </a> <a href=https://www.linkedin.com/in/PabloABC rel="noopener noreferrer" target=_blank title=LinkedIn aria-label=LinkedIn class="nav-item sm svelte-ql1677"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z" fill=currentColor></path></svg> </a> <a href=https://twitter.com/Pablo_ABC rel="noopener noreferrer" target=_blank title=Twitter aria-label=Twitter class="nav-item sm svelte-ql1677"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 512 512" xmlns=http://www.w3.org/2000/svg><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z" fill=currentColor></path></svg> </a></div> </nav></header> <main class=svelte-omxq6j> <article class=main itemscope itemtype=https://schema.org/BlogPosting><header class="svelte-1yyein title"><h1 class=svelte-1yyein><span class=svelte-1yyein itemprop=headline>GraphQL: Is it worth the switch?</span></h1> <h4 class="svelte-1yyein description"><span class=svelte-1yyein itemprop=alternativeHeadline>A nice alternative to REST APIs with a fantastic developer experience</span></h4></header> <div><img alt="Peloponnese, Greece" class="banner svelte-tfh79e" itemprop=image src=img/blog-pics/2019-06-11-placeholder.jpg title="Peloponnese, Greece"> <div class="svelte-1yyein ttr-created"><span class="svelte-1yyein ttr"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 512 512" xmlns=http://www.w3.org/2000/svg><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z" fill=currentColor></path></svg> 10 min </span> <span class="svelte-1yyein created"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z" fill=currentColor></path></svg> <span class=svelte-1yyein itemprop=dateCreated>2019-06-11</span></span></div> <div class="svelte-1yyein tag-links">Tags: <a href=blog/tags/graphql class="svelte-1yyein tag-link">graphql </a><a href=blog/tags/rest class="svelte-1yyein tag-link">rest </a><a href=blog/tags/api class="svelte-1yyein tag-link">api </a></div> <section class="svelte-1yyein content"><p>This past year working as a web developer I’ve been basically breathing <a href=https://en.wikipedia.org/wiki/Representational_state_transfer rel="noopener noreferrer" target=_blank title=REST> REST </a> everyday. While it is not that much time, it has been more than enough to appreciate the simplicity over SOAP, and to loathe the moments in which client requirements or other situations force you to write endpoints that are not <a href=https://restfulapi.net/rest-architectural-constraints/ rel="noopener noreferrer" target=_blank title=RESTful> RESTful </a>. While REST is a standard already for making modern web APIs, for quite a while there has been a new kid on the block that I hadn’t pushed myself to learn about: <a href=https://graphql.org rel="noopener noreferrer" target=_blank title=GraphQL> GraphQL </a>. But that has changed now and I have been experimenting quite a bit using it on the client and on the server.</p> <p>According to <a href=https://graphql.org rel="noopener noreferrer" target=_blank title=graphql.org> graphql.org </a>, “GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data”. A server implementing the GraphQL specification should be able to receive a query sent by the client, containing a description of the specific data the client needs, and it should be able to provide this data as the client asked.</p> <p>But before talking more about GraphQL, let's start by checking what's so great about REST.</p> <h2 id=rest>REST</h2> <p>REST is an architectural style that defines a set of constraint to build web services. When someone speaks about an API that follows the REST architecture, they usually mean a server that communicates with the client via HTTP. The client leverages the different HTTP methods (GET, POST, PUT, PATCH, DELETE) to send requests to URIs in the API that represent resources.</p> <p>Some examples of REST endpoints can be:</p> <pre class="hljs http"><code>GET http://api.example.com/accounts

GET http://api.example.com/accounts/8326

GET http://api.example.com/accounts/8326/posts

GET http://api.example.com/posts/4123/comments</code></pre><p>Depending on which method is used to call the endpoint, a different operation will be applied to the resource.</p> <table> <thead> <tr> <th>METHOD</th> <th>ENDPOINT</th> <th>DESCRIPTION</th> <th>RESPONSE STATUS</th> </tr> </thead> <tr> <td>GET</td> <td>/resources</td> <td>Retrieve a list of elements</td> <td>200</td> </tr> <tr> <td>GET</td> <td>/resources/{id}</td> <td>Retrieve a single element</td> <td>200, 404</td> </tr> <tr> <td>POST</td> <td>/resources</td> <td>Create an element</td> <td>201, 400</td> </tr> <tr> <td>PUT</td> <td>/resources/{id}</td> <td>Update a whole element</td> <td>200, 400</td> </tr> <tr> <td>PATCH</td> <td>/resources/{id}</td> <td>Update specific fields of an element</td> <td>200, 400</td> </tr> <tr> <td>DELETE</td> <td>/resources/{id}</td> <td>Delete an element</td> <td>204, 200, 404</td> </tr> </table> <p>This gives us a clean and predictable interface on which we can operate on the resources on the server.</p> <p>As you saw in the endpoints examples above, REST endpoints can follow a hierarchical structure. Say, if you perform a POST operation on the endpoint <code>/accounts/8326/posts</code>, it should mean you are creating a post that belongs to the account with the id 8326.</p> <p>I've talked about how a REST API looks like to the client, but the characteristics described before are not enough for an API to be considered a REST API. In order to be classified as such, it should follow six constraints:</p> <ul> <li><strong>Uniform interface</strong>: A REST API must have a well defined and consistent interface. This interface must be followed almost religiously in all resources exposed by the API. It must have consistent naming conventions, data format, etc.</li> <li><strong>Client-server</strong>: There must be a clear separation between client and server.</li> <li><strong>Stateless</strong>: All client interactions with the server must be stateless. That means the server must assume each request made to it is completely new, without any knowledge of previous states of the client.</li> <li><strong>Cacheable</strong>: If a REST endpoint is stable enough it could be cached, be it in the server or in the client. Cacheable endpoints must explicitly state they are so.</li> <li><strong>Layered system</strong>: A system architecture can be layered, meaning the client might be interacting with different servers but still acting as if its interacting directly with the REST API.</li> <li><strong>Code on demand</strong>: This is the only optional constraint of the REST architecture. It means, when needed, a REST endpoint may return executable code as a response from a client's request.</li> </ul> <p>This constraints all bring some benefits to the table:</p> <ul> <li>A uniform interface allows clients to intuitively navigate on your API when they start to get used to id.</li> <li>A well defined interface makes it easier to organize your code based on resources.</li> <li>A client-server architecture allows each, the client and the server, to evolve independently.</li> <li>A stateless server allows for theoretically unlimited scalability. Since the server should not be aware of the client's state, in high loads a server can be replicated without worries.</li> <li>Cacheable endpoints help reduce the load on the server.</li> <li>A layered system allows the client to pass by many intermediaries (e.g. authorization) while still interacting the same way with the server.</li> </ul> <p>Although the most common data format a REST API works with is JSON, if needed, a REST API may work with different ones (e.g. XML). Also, although most REST APIs available publicly are served over HTTP, a REST API can theoretically be served over a different protocol.</p> <p>As you can see, a properly developed REST API comes with many benefits, but there's also some caveats on all this:</p> <ul> <li>Since there's no clear standard (besides the six constraints) on how a REST API should behave, there's a lot of design choices that are up to the developer. This means that you won't necessarilly be able to interact with two REST APIs the same way.</li> <li>Unless proper filters are implemented on the server, a REST endpoint may return a lot more information than the client needs.</li> <li>Since REST endpoints are clearly divided by resources, in order to populate the information needed in a client view the client might need to do many requests to the server.</li> <li>Consistency is hard. The developing team must actively try to maintain consistency which means more effort when developing. It's easy to add inconsistencies to the server.</li> <li>Deadlines, client requirements, etc. might push you to break some of the REST constraints which might end up on a mix of various architectures (e.g. RPC).</li> </ul> <p>This shows that building a proper REST API is not an easy task. There are some pitfalls on which the developing team might fall making the final result not being a REST API, losing some of the benefits provided by the REST constraints.</p> <p>So what does GraphQL bring to the table?</p> <h2 id=graphql>GraphQL</h2> <p>As said before, GraphQL is described as a query language for APIs. Unlike REST, GraphQL defines a single endpoint that accepts all operations to the server by sending a parameter called "query" alongside the request. Requests are generally done via a POST request to the GraphQL endpoint, but the specification allows for GET requests as long as it is read only.</p> <p>There are two types of requests you can make to a GraphQL API: queries or mutations. A query request may look like this:</p> <pre class="hljs graphql"><code>{
  post(id:<span class=hljs-string>"1"</span>) {
    id
    title
    content
    author {
      id
      email
    }
}</code></pre><p>This means there should be a schema of the type "query" with the name "post" defined in the server. This query is asking for the id, title, content, author's id and author's email of the post with id "1". If found, the response will follow the same structure described in the query. A GraphQL query would be analogous to performing a GET request on a REST API endpoint.</p> <p>A GraphQL mutation may look like this:</p> <pre class="hljs graphql"><code><span class=hljs-keyword>mutation</span> {
  createAccount(
    email:<span class=hljs-string>"pablo@berganza.dev"</span>
    password:<span class=hljs-string>"super secure password"</span>
  ) {
    id
    email
  }
}</code></pre><p>This assumes that there is a schema of the type "mutation" named "createAccount" defined in the server. This mutation is asking the server to create an account with the specified email and password, and following its creation to return its id and email.</p> <p>GraphQL shouldn't be considered an architectural style. It is more like a collection of tools that facilitate the development of an RPC style API (since you're always calling remote procedures). Even though, a GraphQL API shares some similarities with a REST API:</p> <ul> <li>There's a clear separation between client and server.</li> <li>The server should be stateless.</li> <li>Even though most GraphQL APIs are served over HTTP, it could be served over a different protocol.</li> </ul> <p>Apart from that, a GraphQL API has other advantages over a REST API:</p> <ul> <li>A highly consistent interface to the client since the client-server communication is done using an already well defined query language.</li> <li>It's self documenting. When schemas are defined, they can also be available for the client to see. It is also possible to include docstrings to the schemas in order to explain them more thoroughly.</li> <li>The tooling available provides an enjoyable developer experience. Tools like Graphiql and GraphQL playground can make exploring the schemas on a GraphQL API really easy, and some client-side libraries such as Apollo can provide a lot of other tools to add functionality to the client.</li> <li>Since the moment the schemas are defined, there's a contract between client and server. Schemas must include the properties and data types expected on input and response. Properties may also be added later to the schema, and it is usually not recommended to remove properties.</li> <li>The entry barrier for designing a GraphQL API compared to a proper REST API is much lower.</li> <li>There are many server-side implementations for most of the major programming languages that follow the exact GraphQL specification, so the interaction with different GraphQL APIs should remain consistent.</li> <li>Reduces considerably the requests to the server, since all information can be potentially requested with a single request.</li> </ul> <p>But, of course, there are not only advantages in the GraphQL world. We're losing some of the advantages provided by REST architecture when implementing a GraphQL API, and there's also some other caveats to it:</p> <ul> <li>Even though it is generally served over HTTP, it loses many of the benefits provided by it such as caching, rate limiting, etc. This reduces its potential scalability.</li> <li>A GraphQL API is potentially less efficient than a REST API. Due to the unpredictable complexity of the requests made to the server, a single request to the server can turn into N+1 operations.</li> <li>Being published on 2015 (and starting to being developed in 2012) it could be argued that the ecosystem is still not mature and there's a possibility for considerable changes.</li> <li>For simple applications, requests can be made using the fetch API or libraries like Axios. But, if the application grows, a GraphQL library (such as Apollo Client) might be needed, which would increase the resulting bundle size.</li> <li>It can considerably increase the server's code complexity when optimizations are needed.</li> <li>GraphQL generally always returns a 200 status. Since many queries/mutations might be sent in a single request, and some of them may succeed or fail for various reasons, error management can become complicated on the client side.</li> </ul> <p>I didn't talk about many othe features on the GraphQL specification, such as fragments, named queries and mutations, variables, etc. So make sure to check <a href=https://graphql.org rel="noopener noreferrer" target=_blank title=graphql.org> graphql.org </a> in order to learn more about it if you're interested.</p> <h2 id=conclusion>Conclusion</h2> <p>So, is it worth the switch? As with every debate between two competing technologies: yes and no. There are use cases for both REST and GraphQL. For example, a GraphQL API may be useful when developing needs to start before client requirements are properly established, and it may help keep a consistent API when without much effort. In the end, you always have to evaluate each of their advantages and disadvantages and choose the appropriate one for the job.</p> </section> <footer class=svelte-1yyein><ul class="svelte-12fd6e6 share-buttons"><li class=svelte-12fd6e6>Share this:</li> <li class=svelte-12fd6e6><a href="https://www.facebook.com/sharer/sharer.php?u=https://pablo.berganza.dev/graphql-is-it-worth-the-switch&quote=A nice alternative to REST APIs with a fantastic developer experience" rel="noopener noreferrer" target=_blank title="Share on Facebook"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h137.25V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.27c-30.81 0-40.42 19.12-40.42 38.73V256h68.78l-11 71.69h-57.78V480H400a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48z" fill=currentColor></path></svg> <span class="sr-only svelte-nn0nch">Share on Facebook</span> </a></li> <li class=svelte-12fd6e6><a href="https://twitter.com/intent/tweet?source=https://pablo.berganza.dev/graphql-is-it-worth-the-switch&text=A nice alternative to REST APIs with a fantastic developer experience:%20https://pablo.berganza.dev/graphql-is-it-worth-the-switch&via=Pablo_ABC" rel="noopener noreferrer" target=_blank title=Tweet><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z" fill=currentColor></path></svg> <span class="sr-only svelte-nn0nch">Tweet</span> </a></li> <li class=svelte-12fd6e6><a href="https://getpocket.com/save?url=https://pablo.berganza.dev/graphql-is-it-worth-the-switch&title=GraphQL: Is it worth the switch?" rel="noopener noreferrer" target=_blank title="Add to Pocket"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M407.6 64h-367C18.5 64 0 82.5 0 104.6v135.2C0 364.5 99.7 464 224.2 464c124 0 223.8-99.5 223.8-224.2V104.6c0-22.4-17.7-40.6-40.4-40.6zm-162 268.5c-12.4 11.8-31.4 11.1-42.4 0C89.5 223.6 88.3 227.4 88.3 209.3c0-16.9 13.8-30.7 30.7-30.7 17 0 16.1 3.8 105.2 89.3 90.6-86.9 88.6-89.3 105.5-89.3 16.9 0 30.7 13.8 30.7 30.7 0 17.8-2.9 15.7-114.8 123.2z" fill=currentColor></path></svg> <span class="sr-only svelte-nn0nch">Add to Pocket</span> </a></li> <li class=svelte-12fd6e6><a href="http://www.reddit.com/submit?url=https://pablo.berganza.dev/graphql-is-it-worth-the-switch&title=GraphQL: Is it worth the switch?" rel="noopener noreferrer" target=_blank title="Submit to Reddit"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M283.2 345.5c2.7 2.7 2.7 6.8 0 9.2-24.5 24.5-93.8 24.6-118.4 0-2.7-2.4-2.7-6.5 0-9.2 2.4-2.4 6.5-2.4 8.9 0 18.7 19.2 81 19.6 100.5 0 2.4-2.3 6.6-2.3 9 0zm-91.3-53.8c0-14.9-11.9-26.8-26.5-26.8-14.9 0-26.8 11.9-26.8 26.8 0 14.6 11.9 26.5 26.8 26.5 14.6 0 26.5-11.9 26.5-26.5zm90.7-26.8c-14.6 0-26.5 11.9-26.5 26.8 0 14.6 11.9 26.5 26.5 26.5 14.9 0 26.8-11.9 26.8-26.5 0-14.9-11.9-26.8-26.8-26.8zM448 80v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V80c0-26.5 21.5-48 48-48h352c26.5 0 48 21.5 48 48zm-99.7 140.6c-10.1 0-19 4.2-25.6 10.7-24.1-16.7-56.5-27.4-92.5-28.6l18.7-84.2 59.5 13.4c0 14.6 11.9 26.5 26.5 26.5 14.9 0 26.8-12.2 26.8-26.8 0-14.6-11.9-26.8-26.8-26.8-10.4 0-19.3 6.2-23.8 14.9l-65.7-14.6c-3.3-.9-6.5 1.5-7.4 4.8l-20.5 92.8c-35.7 1.5-67.8 12.2-91.9 28.9-6.5-6.8-15.8-11-25.9-11-37.5 0-49.8 50.4-15.5 67.5-1.2 5.4-1.8 11-1.8 16.7 0 56.5 63.7 102.3 141.9 102.3 78.5 0 142.2-45.8 142.2-102.3 0-5.7-.6-11.6-2.1-17 33.6-17.2 21.2-67.2-16.1-67.2z" fill=currentColor></path></svg> <span class="sr-only svelte-nn0nch">Submit to Reddit</span> </a></li> <li class=svelte-12fd6e6><a href="http://www.linkedin.com/shareArticle?mini=true&url=https://pablo.berganza.dev/graphql-is-it-worth-the-switch&title=GraphQL: Is it worth the switch?&summary=A nice alternative to REST APIs with a fantastic developer experience&source=https://pablo.berganza.dev/graphql-is-it-worth-the-switch" rel="noopener noreferrer" target=_blank title="Share on LinkedIn"><svg aria-hidden=true class="fa-svelte svelte-1gtc9ka" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z" fill=currentColor></path></svg> <span class="sr-only svelte-nn0nch">Share on LinkedIn</span> </a></li> </ul> <label class="svelte-d1ahnf visuallyhidden" for=commento-textarea-root>Comment</label> <div class=svelte-d1ahnf id=commento></div> </footer></div> </article> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{blog:{attributes:{title:"GraphQL: Is it worth the switch?",description:"A nice alternative to REST APIs with a fantastic developer experience",created:"2019-06-11",banner:"img\u002Fblog-pics\u002F2019-06-11.jpg",bannertitle:"Peloponnese, Greece",tags:["graphql","rest","api"]},body:"This past year working as a web developer I’ve been basically breathing [REST](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRepresentational_state_transfer) everyday. While it is not that much time, it has been more than enough to appreciate the simplicity over SOAP, and to loathe the moments in which client requirements or other situations force you to write endpoints that are not [RESTful](https:\u002F\u002Frestfulapi.net\u002Frest-architectural-constraints\u002F). While REST is a standard already for making modern web APIs, for quite a while there has been a new kid on the block that I hadn’t pushed myself to learn about: [GraphQL](https:\u002F\u002Fgraphql.org). But that has changed now and I have been experimenting quite a bit using it on the client and on the server.\n\nAccording to [graphql.org](https:\u002F\u002Fgraphql.org), “GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data”. A server implementing the GraphQL specification should be able to receive a query sent by the client, containing a description of the specific data the client needs, and it should be able to provide this data as the client asked.\n\nBut before talking more about GraphQL, let's start by checking what's so great about REST.\n\n## REST\n\nREST is an architectural style that defines a set of constraint to build web services. When someone speaks about an API that follows the REST architecture, they usually mean a server that communicates with the client via HTTP. The client leverages the different HTTP methods (GET, POST, PUT, PATCH, DELETE) to send requests to URIs in the API that represent resources.\n\nSome examples of REST endpoints can be:\n\n```http\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\n\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\u002F8326\n\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\u002F8326\u002Fposts\n\nGET http:\u002F\u002Fapi.example.com\u002Fposts\u002F4123\u002Fcomments\n```\n\nDepending on which method is used to call the endpoint, a different operation will be applied to the resource.\n\n| METHOD | ENDPOINT        | DESCRIPTION                          | RESPONSE STATUS |\n|--------|-----------------|--------------------------------------|-----------------|\n| GET    | \u002Fresources      | Retrieve a list of elements          | 200             |\n| GET    | \u002Fresources\u002F{id} | Retrieve a single element            | 200, 404        |\n| POST   | \u002Fresources      | Create an element                    | 201, 400        |\n| PUT    | \u002Fresources\u002F{id} | Update a whole element               | 200, 400        |\n| PATCH  | \u002Fresources\u002F{id} | Update specific fields of an element | 200, 400        |\n| DELETE | \u002Fresources\u002F{id} | Delete an element                    | 204, 200, 404   |\n\nThis gives us a clean and predictable interface on which we can operate on the resources on the server.\n\nAs you saw in the endpoints examples above, REST endpoints can follow a hierarchical structure. Say, if you perform a POST operation on the endpoint `\u002Faccounts\u002F8326\u002Fposts`, it should mean you are creating a post that belongs to the account with the id 8326.\n\nI've talked about how a REST API looks like to the client, but the characteristics described before are not enough for an API to be considered a REST API. In order to be classified as such, it should follow six constraints:\n\n  * **Uniform interface**: A REST API must have a well defined and consistent interface. This interface must be followed almost religiously in all resources exposed by the API. It must have consistent naming conventions, data format, etc.\n  * **Client-server**: There must be a clear separation between client and server.\n  * **Stateless**: All client interactions with the server must be stateless. That means the server must assume each request made to it is completely new, without any knowledge of previous states of the client.\n  * **Cacheable**: If a REST endpoint is stable enough it could be cached, be it in the server or in the client. Cacheable endpoints must explicitly state they are so.\n  * **Layered system**: A system architecture can be layered, meaning the client might be interacting with different servers but still acting as if its interacting directly with the REST API.\n  * **Code on demand**: This is the only optional constraint of the REST architecture. It means, when needed, a REST endpoint may return executable code as a response from a client's request.\n\nThis constraints all bring some benefits to the table:\n\n  * A uniform interface allows clients to intuitively navigate on your API when they start to get used to id.\n  * A well defined interface makes it easier to organize your code based on resources.\n  * A client-server architecture allows each, the client and the server, to evolve independently.\n  * A stateless server allows for theoretically unlimited scalability. Since the server should not be aware of the client's state, in high loads a server can be replicated without worries.\n  * Cacheable endpoints help reduce the load on the server.\n  * A layered system allows the client to pass by many intermediaries (e.g. authorization) while still interacting the same way with the server.\n\nAlthough the most common data format a REST API works with is JSON, if needed, a REST API may work with different ones (e.g. XML). Also, although most REST APIs available publicly are served over HTTP, a REST API can theoretically be served over a different protocol.\n\nAs you can see, a properly developed REST API comes with many benefits, but there's also some caveats on all this:\n\n  * Since there's no clear standard (besides the six constraints) on how a REST API should behave, there's a lot of design choices that are up to the developer. This means that you won't necessarilly be able to interact with two REST APIs the same way.\n  * Unless proper filters are implemented on the server, a REST endpoint may return a lot more information than the client needs.\n  * Since REST endpoints are clearly divided by resources, in order to populate the information needed in a client view the client might need to do many requests to the server.\n  * Consistency is hard. The developing team must actively try to maintain consistency which means more effort when developing. It's easy to add inconsistencies to the server.\n  * Deadlines, client requirements, etc. might push you to break some of the REST constraints which might end up on a mix of various architectures (e.g. RPC).\n\nThis shows that building a proper REST API is not an easy task. There are some pitfalls on which the developing team might fall making the final result not being a REST API, losing some of the benefits provided by the REST constraints.\n\nSo what does GraphQL bring to the table?\n\n## GraphQL\n\nAs said before, GraphQL is described as a query language for APIs. Unlike REST, GraphQL defines a single endpoint that accepts all operations to the server by sending a parameter called \"query\" alongside the request. Requests are generally done via a POST request to the GraphQL endpoint, but the specification allows for GET requests as long as it is read only.\n\nThere are two types of requests you can make to a GraphQL API: queries or mutations. A query request may look like this:\n\n```graphql\n{\n  post(id:\"1\") {\n    id\n    title\n    content\n    author {\n      id\n      email\n    }\n}\n```\n\nThis means there should be a schema of the type \"query\" with the name \"post\" defined in the server. This query is asking for the id, title, content, author's id and author's email of the post with id \"1\". If found, the response will follow the same structure described in the query. A GraphQL query would be analogous to performing a GET request on a REST API endpoint.\n\nA GraphQL mutation may look like this:\n\n```graphql\nmutation {\n  createAccount(\n    email:\"pablo@berganza.dev\"\n    password:\"super secure password\"\n  ) {\n    id\n    email\n  }\n}\n```\n\nThis assumes that there is a schema of the type \"mutation\" named \"createAccount\" defined in the server. This mutation is asking the server to create an account with the specified email and password, and following its creation to return its id and email.\n\nGraphQL shouldn't be considered an architectural style. It is more like a collection of tools that facilitate the development of an RPC style API (since you're always calling remote procedures). Even though, a GraphQL API shares some similarities with a REST API:\n\n  * There's a clear separation between client and server.\n  * The server should be stateless.\n  * Even though most GraphQL APIs are served over HTTP, it could be served over a different protocol.\n\nApart from that, a GraphQL API has other advantages over a REST API:\n\n  * A highly consistent interface to the client since the client-server communication is done using an already well defined query language.\n  * It's self documenting. When schemas are defined, they can also be available for the client to see. It is also possible to include docstrings to the schemas in order to explain them more thoroughly.\n  * The tooling available provides an enjoyable developer experience. Tools like Graphiql and GraphQL playground can make exploring the schemas on a GraphQL API really easy, and some client-side libraries such as Apollo can provide a lot of other tools to add functionality to the client.\n  * Since the moment the schemas are defined, there's a contract between client and server. Schemas must include the properties and data types expected on input and response. Properties may also be added later to the schema, and it is usually not recommended to remove properties.\n  * The entry barrier for designing a GraphQL API compared to a proper REST API is much lower.\n  * There are many server-side implementations for most of the major programming languages that follow the exact GraphQL specification, so the interaction with different GraphQL APIs should remain consistent.\n  * Reduces considerably the requests to the server, since all information can be potentially requested with a single request.\n\nBut, of course, there are not only advantages in the GraphQL world. We're losing some of the advantages provided by REST architecture when implementing a GraphQL API, and there's also some other caveats to it:\n\n  * Even though it is generally served over HTTP, it loses many of the benefits provided by it such as caching, rate limiting, etc. This reduces its potential scalability.\n  * A GraphQL API is potentially less efficient than a REST API. Due to the unpredictable complexity of the requests made to the server, a single request to the server can turn into N+1 operations.\n  * Being published on 2015 (and starting to being developed in 2012) it could be argued that the ecosystem is still not mature and there's a possibility for considerable changes.\n  * For simple applications, requests can be made using the fetch API or libraries like Axios. But, if the application grows, a GraphQL library (such as Apollo Client) might be needed, which would increase the resulting bundle size.\n  * It can considerably increase the server's code complexity when optimizations are needed.\n  * GraphQL generally always returns a 200 status. Since many queries\u002Fmutations might be sent in a single request, and some of them may succeed or fail for various reasons, error management can become complicated on the client side.\n\nI didn't talk about many othe features on the GraphQL specification, such as fragments, named queries and mutations, variables, etc. So make sure to check [graphql.org](https:\u002F\u002Fgraphql.org) in order to learn more about it if you're interested.\n\n## Conclusion\n\nSo, is it worth the switch? As with every debate between two competing technologies: yes and no. There are use cases for both REST and GraphQL. For example, a GraphQL API may be useful when developing needs to start before client requirements are properly established, and it may help keep a consistent API when without much effort. In the end, you always have to evaluate each of their advantages and disadvantages and choose the appropriate one for the job.\n",bodyBegin:13,frontmatter:"title: 'GraphQL: Is it worth the switch?'\ndescription: A nice alternative to REST APIs with a fantastic developer experience\ncreated: '2019-06-11'\nbanner: img\u002Fblog-pics\u002F2019-06-11.jpg\nbannertitle: Peloponnese, Greece\ntags:\n    - graphql\n    - rest\n    - api",path:"\u002FUsers\u002FPabloABC\u002FDocuments\u002FPersonal\u002FJavaScript\u002FSvelte\u002Fpablo.berganza.dev\u002Fsrc\u002Fmarkdown\u002Fblog\u002F2019-06-11-graphql-is-it-worth-the-switch\u002Findex.en.md",html:"\u003Cp\u003EThis past year working as a web developer I’ve been basically breathing \u003Ca\n            href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRepresentational_state_transfer\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"REST\"\n          \u003E\n            REST\n          \u003C\u002Fa\u003E everyday. While it is not that much time, it has been more than enough to appreciate the simplicity over SOAP, and to loathe the moments in which client requirements or other situations force you to write endpoints that are not \u003Ca\n            href=\"https:\u002F\u002Frestfulapi.net\u002Frest-architectural-constraints\u002F\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"RESTful\"\n          \u003E\n            RESTful\n          \u003C\u002Fa\u003E. While REST is a standard already for making modern web APIs, for quite a while there has been a new kid on the block that I hadn’t pushed myself to learn about: \u003Ca\n            href=\"https:\u002F\u002Fgraphql.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"GraphQL\"\n          \u003E\n            GraphQL\n          \u003C\u002Fa\u003E. But that has changed now and I have been experimenting quite a bit using it on the client and on the server.\u003C\u002Fp\u003E\n\u003Cp\u003EAccording to \u003Ca\n            href=\"https:\u002F\u002Fgraphql.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"graphql.org\"\n          \u003E\n            graphql.org\n          \u003C\u002Fa\u003E, “GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data”. A server implementing the GraphQL specification should be able to receive a query sent by the client, containing a description of the specific data the client needs, and it should be able to provide this data as the client asked.\u003C\u002Fp\u003E\n\u003Cp\u003EBut before talking more about GraphQL, let&#39;s start by checking what&#39;s so great about REST.\u003C\u002Fp\u003E\n\u003Ch2 id=\"rest\"\u003EREST\u003C\u002Fh2\u003E\n\u003Cp\u003EREST is an architectural style that defines a set of constraint to build web services. When someone speaks about an API that follows the REST architecture, they usually mean a server that communicates with the client via HTTP. The client leverages the different HTTP methods (GET, POST, PUT, PATCH, DELETE) to send requests to URIs in the API that represent resources.\u003C\u002Fp\u003E\n\u003Cp\u003ESome examples of REST endpoints can be:\u003C\u002Fp\u003E\n\u003Cpre class=\"http hljs\"\u003E\u003Ccode\u003EGET http:\u002F\u002Fapi.example.com\u002Faccounts\n\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\u002F8326\n\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\u002F8326\u002Fposts\n\nGET http:\u002F\u002Fapi.example.com\u002Fposts\u002F4123\u002Fcomments\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EDepending on which method is used to call the endpoint, a different operation will be applied to the resource.\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003EMETHOD\u003C\u002Fth\u003E\n\u003Cth\u003EENDPOINT\u003C\u002Fth\u003E\n\u003Cth\u003EDESCRIPTION\u003C\u002Fth\u003E\n\u003Cth\u003ERESPONSE STATUS\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003EGET\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u003C\u002Ftd\u003E\n\u003Ctd\u003ERetrieve a list of elements\u003C\u002Ftd\u003E\n\u003Ctd\u003E200\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EGET\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u002F{id}\u003C\u002Ftd\u003E\n\u003Ctd\u003ERetrieve a single element\u003C\u002Ftd\u003E\n\u003Ctd\u003E200, 404\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EPOST\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u003C\u002Ftd\u003E\n\u003Ctd\u003ECreate an element\u003C\u002Ftd\u003E\n\u003Ctd\u003E201, 400\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EPUT\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u002F{id}\u003C\u002Ftd\u003E\n\u003Ctd\u003EUpdate a whole element\u003C\u002Ftd\u003E\n\u003Ctd\u003E200, 400\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EPATCH\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u002F{id}\u003C\u002Ftd\u003E\n\u003Ctd\u003EUpdate specific fields of an element\u003C\u002Ftd\u003E\n\u003Ctd\u003E200, 400\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EDELETE\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u002F{id}\u003C\u002Ftd\u003E\n\u003Ctd\u003EDelete an element\u003C\u002Ftd\u003E\n\u003Ctd\u003E204, 200, 404\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Cp\u003EThis gives us a clean and predictable interface on which we can operate on the resources on the server.\u003C\u002Fp\u003E\n\u003Cp\u003EAs you saw in the endpoints examples above, REST endpoints can follow a hierarchical structure. Say, if you perform a POST operation on the endpoint \u003Ccode\u003E\u002Faccounts\u002F8326\u002Fposts\u003C\u002Fcode\u003E, it should mean you are creating a post that belongs to the account with the id 8326.\u003C\u002Fp\u003E\n\u003Cp\u003EI&#39;ve talked about how a REST API looks like to the client, but the characteristics described before are not enough for an API to be considered a REST API. In order to be classified as such, it should follow six constraints:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003EUniform interface\u003C\u002Fstrong\u003E: A REST API must have a well defined and consistent interface. This interface must be followed almost religiously in all resources exposed by the API. It must have consistent naming conventions, data format, etc.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EClient-server\u003C\u002Fstrong\u003E: There must be a clear separation between client and server.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EStateless\u003C\u002Fstrong\u003E: All client interactions with the server must be stateless. That means the server must assume each request made to it is completely new, without any knowledge of previous states of the client.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ECacheable\u003C\u002Fstrong\u003E: If a REST endpoint is stable enough it could be cached, be it in the server or in the client. Cacheable endpoints must explicitly state they are so.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ELayered system\u003C\u002Fstrong\u003E: A system architecture can be layered, meaning the client might be interacting with different servers but still acting as if its interacting directly with the REST API.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ECode on demand\u003C\u002Fstrong\u003E: This is the only optional constraint of the REST architecture. It means, when needed, a REST endpoint may return executable code as a response from a client&#39;s request.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EThis constraints all bring some benefits to the table:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EA uniform interface allows clients to intuitively navigate on your API when they start to get used to id.\u003C\u002Fli\u003E\n\u003Cli\u003EA well defined interface makes it easier to organize your code based on resources.\u003C\u002Fli\u003E\n\u003Cli\u003EA client-server architecture allows each, the client and the server, to evolve independently.\u003C\u002Fli\u003E\n\u003Cli\u003EA stateless server allows for theoretically unlimited scalability. Since the server should not be aware of the client&#39;s state, in high loads a server can be replicated without worries.\u003C\u002Fli\u003E\n\u003Cli\u003ECacheable endpoints help reduce the load on the server.\u003C\u002Fli\u003E\n\u003Cli\u003EA layered system allows the client to pass by many intermediaries (e.g. authorization) while still interacting the same way with the server.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EAlthough the most common data format a REST API works with is JSON, if needed, a REST API may work with different ones (e.g. XML). Also, although most REST APIs available publicly are served over HTTP, a REST API can theoretically be served over a different protocol.\u003C\u002Fp\u003E\n\u003Cp\u003EAs you can see, a properly developed REST API comes with many benefits, but there&#39;s also some caveats on all this:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESince there&#39;s no clear standard (besides the six constraints) on how a REST API should behave, there&#39;s a lot of design choices that are up to the developer. This means that you won&#39;t necessarilly be able to interact with two REST APIs the same way.\u003C\u002Fli\u003E\n\u003Cli\u003EUnless proper filters are implemented on the server, a REST endpoint may return a lot more information than the client needs.\u003C\u002Fli\u003E\n\u003Cli\u003ESince REST endpoints are clearly divided by resources, in order to populate the information needed in a client view the client might need to do many requests to the server.\u003C\u002Fli\u003E\n\u003Cli\u003EConsistency is hard. The developing team must actively try to maintain consistency which means more effort when developing. It&#39;s easy to add inconsistencies to the server.\u003C\u002Fli\u003E\n\u003Cli\u003EDeadlines, client requirements, etc. might push you to break some of the REST constraints which might end up on a mix of various architectures (e.g. RPC).\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EThis shows that building a proper REST API is not an easy task. There are some pitfalls on which the developing team might fall making the final result not being a REST API, losing some of the benefits provided by the REST constraints.\u003C\u002Fp\u003E\n\u003Cp\u003ESo what does GraphQL bring to the table?\u003C\u002Fp\u003E\n\u003Ch2 id=\"graphql\"\u003EGraphQL\u003C\u002Fh2\u003E\n\u003Cp\u003EAs said before, GraphQL is described as a query language for APIs. Unlike REST, GraphQL defines a single endpoint that accepts all operations to the server by sending a parameter called &quot;query&quot; alongside the request. Requests are generally done via a POST request to the GraphQL endpoint, but the specification allows for GET requests as long as it is read only.\u003C\u002Fp\u003E\n\u003Cp\u003EThere are two types of requests you can make to a GraphQL API: queries or mutations. A query request may look like this:\u003C\u002Fp\u003E\n\u003Cpre class=\"graphql hljs\"\u003E\u003Ccode\u003E{\n  post(id:\u003Cspan class=\"hljs-string\"\u003E\"1\"\u003C\u002Fspan\u003E) {\n    id\n    title\n    content\n    author {\n      id\n      email\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThis means there should be a schema of the type &quot;query&quot; with the name &quot;post&quot; defined in the server. This query is asking for the id, title, content, author&#39;s id and author&#39;s email of the post with id &quot;1&quot;. If found, the response will follow the same structure described in the query. A GraphQL query would be analogous to performing a GET request on a REST API endpoint.\u003C\u002Fp\u003E\n\u003Cp\u003EA GraphQL mutation may look like this:\u003C\u002Fp\u003E\n\u003Cpre class=\"graphql hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Emutation\u003C\u002Fspan\u003E {\n  createAccount(\n    email:\u003Cspan class=\"hljs-string\"\u003E\"pablo@berganza.dev\"\u003C\u002Fspan\u003E\n    password:\u003Cspan class=\"hljs-string\"\u003E\"super secure password\"\u003C\u002Fspan\u003E\n  ) {\n    id\n    email\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThis assumes that there is a schema of the type &quot;mutation&quot; named &quot;createAccount&quot; defined in the server. This mutation is asking the server to create an account with the specified email and password, and following its creation to return its id and email.\u003C\u002Fp\u003E\n\u003Cp\u003EGraphQL shouldn&#39;t be considered an architectural style. It is more like a collection of tools that facilitate the development of an RPC style API (since you&#39;re always calling remote procedures). Even though, a GraphQL API shares some similarities with a REST API:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EThere&#39;s a clear separation between client and server.\u003C\u002Fli\u003E\n\u003Cli\u003EThe server should be stateless.\u003C\u002Fli\u003E\n\u003Cli\u003EEven though most GraphQL APIs are served over HTTP, it could be served over a different protocol.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EApart from that, a GraphQL API has other advantages over a REST API:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EA highly consistent interface to the client since the client-server communication is done using an already well defined query language.\u003C\u002Fli\u003E\n\u003Cli\u003EIt&#39;s self documenting. When schemas are defined, they can also be available for the client to see. It is also possible to include docstrings to the schemas in order to explain them more thoroughly.\u003C\u002Fli\u003E\n\u003Cli\u003EThe tooling available provides an enjoyable developer experience. Tools like Graphiql and GraphQL playground can make exploring the schemas on a GraphQL API really easy, and some client-side libraries such as Apollo can provide a lot of other tools to add functionality to the client.\u003C\u002Fli\u003E\n\u003Cli\u003ESince the moment the schemas are defined, there&#39;s a contract between client and server. Schemas must include the properties and data types expected on input and response. Properties may also be added later to the schema, and it is usually not recommended to remove properties.\u003C\u002Fli\u003E\n\u003Cli\u003EThe entry barrier for designing a GraphQL API compared to a proper REST API is much lower.\u003C\u002Fli\u003E\n\u003Cli\u003EThere are many server-side implementations for most of the major programming languages that follow the exact GraphQL specification, so the interaction with different GraphQL APIs should remain consistent.\u003C\u002Fli\u003E\n\u003Cli\u003EReduces considerably the requests to the server, since all information can be potentially requested with a single request.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EBut, of course, there are not only advantages in the GraphQL world. We&#39;re losing some of the advantages provided by REST architecture when implementing a GraphQL API, and there&#39;s also some other caveats to it:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EEven though it is generally served over HTTP, it loses many of the benefits provided by it such as caching, rate limiting, etc. This reduces its potential scalability.\u003C\u002Fli\u003E\n\u003Cli\u003EA GraphQL API is potentially less efficient than a REST API. Due to the unpredictable complexity of the requests made to the server, a single request to the server can turn into N+1 operations.\u003C\u002Fli\u003E\n\u003Cli\u003EBeing published on 2015 (and starting to being developed in 2012) it could be argued that the ecosystem is still not mature and there&#39;s a possibility for considerable changes.\u003C\u002Fli\u003E\n\u003Cli\u003EFor simple applications, requests can be made using the fetch API or libraries like Axios. But, if the application grows, a GraphQL library (such as Apollo Client) might be needed, which would increase the resulting bundle size.\u003C\u002Fli\u003E\n\u003Cli\u003EIt can considerably increase the server&#39;s code complexity when optimizations are needed.\u003C\u002Fli\u003E\n\u003Cli\u003EGraphQL generally always returns a 200 status. Since many queries\u002Fmutations might be sent in a single request, and some of them may succeed or fail for various reasons, error management can become complicated on the client side.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EI didn&#39;t talk about many othe features on the GraphQL specification, such as fragments, named queries and mutations, variables, etc. So make sure to check \u003Ca\n            href=\"https:\u002F\u002Fgraphql.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"graphql.org\"\n          \u003E\n            graphql.org\n          \u003C\u002Fa\u003E in order to learn more about it if you&#39;re interested.\u003C\u002Fp\u003E\n\u003Ch2 id=\"conclusion\"\u003EConclusion\u003C\u002Fh2\u003E\n\u003Cp\u003ESo, is it worth the switch? As with every debate between two competing technologies: yes and no. There are use cases for both REST and GraphQL. For example, a GraphQL API may be useful when developing needs to start before client requirements are properly established, and it may help keep a consistent API when without much effort. In the end, you always have to evaluate each of their advantages and disadvantages and choose the appropriate one for the job.\u003C\u002Fp\u003E\n",ttr:10,slug:"graphql-is-it-worth-the-switch"}}],session:{lang:"en"}};(function(){try{eval("async function x(){}");var main="/client/client.a9a415dd.js"}catch(e){main="/client/legacy/client.8afe815a.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> 