{"attributes":{"title":"You don't really need Apollo","description":"Small project? Learning GraphQL? Apollo might be an overkill","banner":"img/blog-pics/2020-06-08.jpg","bannertitle":"Wroclaw, Poland","tags":["javascript","graphql","react","programming"],"created":"2020-06-08"},"body":"The first time I tried [GraphQL](https://graphql.org) was when I would still have considered myself as just a back-end developer. About two years ago I gave myself the opportunity to learn it thanks to [NestJS](https://nestjs.com)'s support for it and I totally felt in love with it. The fact that it's basically self-documenting and the fact that you can ask for exactly the data you want with just one request made me feel that working with a GraphQL API as a front-end developer would feel really enjoyable.\n\n## Road to front-end GraphQL\n\nI wanted to try to make something on the front-end side with this new knowledge, to get a better feel of it. By that time I was still learning the ropes on front-end with [React](https://reactjs.org) (last time I did front-end, jQuery was the thing to use). So, naturally, I duckduckgo'ed `graphql react` and the first thing I found was [Apollo](https://www.apollographql.com). Apollo is a great tool that offers many features; you can even manage your whole application's state with it. But it did feel a bit _heavy_ for someone who's just trying to learn how to use GraphQL, or for any small project in that sense. I will admit that it was really naive of me, but at the time I really thought: _woah, so GraphQL is really only suitable for pretty big apps_. Regardless, I kept on doing my experiments with Apollo. As I suspected I spent a lot of my time learning how to use Apollo, which is not bad _per se_, but of course it would feel daunting for anyone learning.\n\nSometime about last year I found [urql](https://formidable.com/open-source/urql/) which aims to be a lighter alternative to Apollo. I found this really appealing. And it was great. A simpler API and fewer features meant less time spent on the documentation and more time to actually build something with it. But it still felt pretty heavy for my use cases. Although right now I would probably choose urql over Apollo for a serious project, since I do feel Apollo tries to do too much for my taste.\n\nEven though I haven't worked professionally with GraphQL yet, I've kept on using it for my personal projects. Still, I kept on feeling that the entry point for any front-end developer learning it was quite high. If you duckduckgo (or google) `react graphql` your top results will be Apollo and [howtographql.com](https://www.howtographql.com). If you go to the latter, you'll see that both Apollo and urql are listed as the _beginner's choice_. This I feel is an artificially high entry point for a beginner.\n\n## What's the alternative?\n\nWhat are the minimum requirements for making a request to a GraphQL API from the browser? Well... just the [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) API. After all, you only need to make an HTTP POST request to the GraphQL endpoint. It only needs to contain a query/mutation in the body as a string and, optionally, the variables if they're needed for the query. It doesn't _need_ to be a POST request, and it can have an `application/graphql` MIME type; but, to keep things simple, a POST request with an `application/json` MIME type should always work.\n\n```javascript\nfetch(`${API}/graphql`, {\n  method: 'post',\n  headers: { 'content-type': 'application/json' },\n  body: JSON.stringify({\n    query: `...`,\n    variables: {\n      ...\n    },\n  })\n}).then(r => r.json())\n```\n\nYou can turn this into a more reusable function with something like this:\n\n```javascript\nasync function gqlFetcher(query, variables) {\n  const { data, errors } = await fetch(`${API}/graphql`, {\n    method: 'post',\n    headers: { 'content-type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n  }).then(r => r.json())\n  if (errors) throw errors\n  return data\n}\n```\n\nA GraphQL server returns a 200 response even if it contains errors, so you generally only need to check if the response contains an `errors` property. This is still an optimistic way of handling it, since you're not accounting for other kinds of errors such as network errors that can return 4xx or 5xx responses. For the purposes of this post we'll leave it like this.\n\n## Some nicer ergonomics\n\nThis approach does make you lose the nice interface that Apollo and urql provide you. You can, of course, create your own hooks that provide a friendlier interface; however, I prefer to use Vercel's [swr](https://github.com/vercel/swr) hook. This hook works for any kind of remote data fetching; it works by first returning data from the cache, then sending the fetch request, and finally returning the newly received data. It provides a nice interface for handling your data inside your component while keeping your UI, as they describe it, fast and reactive. The `gqlFetcher` function we made earlier is already compatible with the `useSWR` hook, so no additional work is required.\n\n```javascript\nimport useSWR from 'swr'\n\nconst gqlQuery = `...`\n\nfunction Component() {\n  // gqlFetcher is the same function we defined earlier\n  const { data, error } = useSWR(gqlQuery, gqlFetcher)\n\n  if (error) return <div>{/*...*/}</div> // JSX with error data\n  if (!data) return <div>Loading...</div> // Loading component\n  return <div>{/*...*/}</div> // JSX with returned data\n}\n```\n\nIn order to pass multiple arguments to the `fetcher` function, the swr hook allows you to pass an array as the first argument.\n\n```javascript\nconst gqlQuery = `...`\nconst gqlVariables = {\n  // ...\n}\n\nfunction Component() {\n  const { data, error } = useSWR([gqlQuery, gqlVariables], gqlFetcher)\n  // ...\n}\n```\n\n> `useSWR` uses the first argument as a `key` that serves to uniquely identify the request. If an array is passed, `swr` shallowly compares each element and, if any of them has changed, it revalidates the request.\n\n## Existing tooling\n\nIf you don't feel like creating your own wrapper over `fetch`, you can use [graphql-request](https://github.com/prisma-labs/graphql-request). This is also a wrapper over the `fetch` API for making GraphQL requests that doesn't need much work to start using it. It already handles errors nicely and is isomorphic by default (which some people might not like). The `swr` GitHub page already provides an example using this.\n\n```javascript\nimport { request } from 'graphql-request'\n\nconst API = 'https://api.graph.cool/simple/v1/movies'\nconst fetcher = query => request(API, query)\n\nfunction App () {\n  const { data, error } = useSWR(\n    `{\n      Movie(title: \"Inception\") {\n        releaseDate\n        actors {\n          name\n        }\n      }\n    }`,\n    fetcher\n  )\n  // ...\n}\n```\n\n## Conclusion\n\nIt feels there's an artificially high entry level for front-end developers who want to get into the GraphQL world. The fact that Apollo and urql are shown as _beginner_ choices for learning GraphQL can make developers feel like these kinds of tools are actually _required_ to work with a GraphQL API. This is, in fact, not the case; you **can** build a fully capable web application with just the `fetch` API and some other small libraries for extra features. I can't think of any small project that would actually require all the features that these big libraries have to offer. To clarify: I'm not saying you shouldn't use these tools if you want to; I'm saying you don't need to feel they're _required_ to build what you want.\n","bodyBegin":13,"frontmatter":"title: \"You don't really need Apollo\"\ndescription: Small project? Learning GraphQL? Apollo might be an overkill\nbanner: img/blog-pics/2020-06-08.jpg\nbannertitle: Wroclaw, Poland\ntags:\n  - javascript\n  - graphql\n  - react\n  - programming","path":"/home/runner/work/pablo.berganza.dev-sapper/pablo.berganza.dev-sapper/src/markdown/blog/2020-06-08-you-dont-need-apollo/index.en.md","html":"<p>The first time I tried <a\n            href=\"https://graphql.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"GraphQL\"\n          >\n            GraphQL\n          </a> was when I would still have considered myself as just a back-end developer. About two years ago I gave myself the opportunity to learn it thanks to <a\n            href=\"https://nestjs.com\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"NestJS\"\n          >\n            NestJS\n          </a>&#39;s support for it and I totally felt in love with it. The fact that it&#39;s basically self-documenting and the fact that you can ask for exactly the data you want with just one request made me feel that working with a GraphQL API as a front-end developer would feel really enjoyable.</p>\n<h2 id=\"road-to-front-end-graphql\">Road to front-end GraphQL</h2>\n<p>I wanted to try to make something on the front-end side with this new knowledge, to get a better feel of it. By that time I was still learning the ropes on front-end with <a\n            href=\"https://reactjs.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"React\"\n          >\n            React\n          </a> (last time I did front-end, jQuery was the thing to use). So, naturally, I duckduckgo&#39;ed <code>graphql react</code> and the first thing I found was <a\n            href=\"https://www.apollographql.com\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Apollo\"\n          >\n            Apollo\n          </a>. Apollo is a great tool that offers many features; you can even manage your whole application&#39;s state with it. But it did feel a bit <em>heavy</em> for someone who&#39;s just trying to learn how to use GraphQL, or for any small project in that sense. I will admit that it was really naive of me, but at the time I really thought: <em>woah, so GraphQL is really only suitable for pretty big apps</em>. Regardless, I kept on doing my experiments with Apollo. As I suspected I spent a lot of my time learning how to use Apollo, which is not bad <em>per se</em>, but of course it would feel daunting for anyone learning.</p>\n<p>Sometime about last year I found <a\n            href=\"https://formidable.com/open-source/urql/\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"urql\"\n          >\n            urql\n          </a> which aims to be a lighter alternative to Apollo. I found this really appealing. And it was great. A simpler API and fewer features meant less time spent on the documentation and more time to actually build something with it. But it still felt pretty heavy for my use cases. Although right now I would probably choose urql over Apollo for a serious project, since I do feel Apollo tries to do too much for my taste.</p>\n<p>Even though I haven&#39;t worked professionally with GraphQL yet, I&#39;ve kept on using it for my personal projects. Still, I kept on feeling that the entry point for any front-end developer learning it was quite high. If you duckduckgo (or google) <code>react graphql</code> your top results will be Apollo and <a\n            href=\"https://www.howtographql.com\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"howtographql.com\"\n          >\n            howtographql.com\n          </a>. If you go to the latter, you&#39;ll see that both Apollo and urql are listed as the <em>beginner&#39;s choice</em>. This I feel is an artificially high entry point for a beginner.</p>\n<h2 id=\"whats-the-alternative\">What&#39;s the alternative?</h2>\n<p>What are the minimum requirements for making a request to a GraphQL API from the browser? Well... just the <a\n            href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"fetch\"\n          >\n            fetch\n          </a> API. After all, you only need to make an HTTP POST request to the GraphQL endpoint. It only needs to contain a query/mutation in the body as a string and, optionally, the variables if they&#39;re needed for the query. It doesn&#39;t <em>need</em> to be a POST request, and it can have an <code>application/graphql</code> MIME type; but, to keep things simple, a POST request with an <code>application/json</code> MIME type should always work.</p>\n<pre class=\"javascript hljs\"><code>fetch(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${API}</span>/graphql`</span>, {\n  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;post&#x27;</span>,\n  <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">&#x27;content-type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span> },\n  <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify({\n    <span class=\"hljs-attr\">query</span>: <span class=\"hljs-string\">`...`</span>,\n    <span class=\"hljs-attr\">variables</span>: {\n      ...\n    },\n  })\n}).then(<span class=\"hljs-function\"><span class=\"hljs-params\">r</span> =&gt;</span> r.json())</code></pre><p>You can turn this into a more reusable function with something like this:</p>\n<pre class=\"javascript hljs\"><code><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">gqlFetcher</span>(<span class=\"hljs-params\">query, variables</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { data, errors } = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${API}</span>/graphql`</span>, {\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;post&#x27;</span>,\n    <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">&#x27;content-type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span> },\n    <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify({ query, variables }),\n  }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">r</span> =&gt;</span> r.json())\n  <span class=\"hljs-keyword\">if</span> (errors) <span class=\"hljs-keyword\">throw</span> errors\n  <span class=\"hljs-keyword\">return</span> data\n}</code></pre><p>A GraphQL server returns a 200 response even if it contains errors, so you generally only need to check if the response contains an <code>errors</code> property. This is still an optimistic way of handling it, since you&#39;re not accounting for other kinds of errors such as network errors that can return 4xx or 5xx responses. For the purposes of this post we&#39;ll leave it like this.</p>\n<h2 id=\"some-nicer-ergonomics\">Some nicer ergonomics</h2>\n<p>This approach does make you lose the nice interface that Apollo and urql provide you. You can, of course, create your own hooks that provide a friendlier interface; however, I prefer to use Vercel&#39;s <a\n            href=\"https://github.com/vercel/swr\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"swr\"\n          >\n            swr\n          </a> hook. This hook works for any kind of remote data fetching; it works by first returning data from the cache, then sending the fetch request, and finally returning the newly received data. It provides a nice interface for handling your data inside your component while keeping your UI, as they describe it, fast and reactive. The <code>gqlFetcher</code> function we made earlier is already compatible with the <code>useSWR</code> hook, so no additional work is required.</p>\n<pre class=\"javascript hljs\"><code><span class=\"hljs-keyword\">import</span> useSWR <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;swr&#x27;</span>\n\n<span class=\"hljs-keyword\">const</span> gqlQuery = <span class=\"hljs-string\">`...`</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Component</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// gqlFetcher is the same function we defined earlier</span>\n  <span class=\"hljs-keyword\">const</span> { data, error } = useSWR(gqlQuery, gqlFetcher)\n\n  <span class=\"hljs-keyword\">if</span> (error) <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{/*...*/}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> <span class=\"hljs-comment\">// JSX with error data</span>\n  <span class=\"hljs-keyword\">if</span> (!data) <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> <span class=\"hljs-comment\">// Loading component</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{/*...*/}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> <span class=\"hljs-comment\">// JSX with returned data</span>\n}</code></pre><p>In order to pass multiple arguments to the <code>fetcher</code> function, the swr hook allows you to pass an array as the first argument.</p>\n<pre class=\"javascript hljs\"><code><span class=\"hljs-keyword\">const</span> gqlQuery = <span class=\"hljs-string\">`...`</span>\n<span class=\"hljs-keyword\">const</span> gqlVariables = {\n  <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Component</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { data, error } = useSWR([gqlQuery, gqlVariables], gqlFetcher)\n  <span class=\"hljs-comment\">// ...</span>\n}</code></pre><blockquote>\n<p><code>useSWR</code> uses the first argument as a <code>key</code> that serves to uniquely identify the request. If an array is passed, <code>swr</code> shallowly compares each element and, if any of them has changed, it revalidates the request.</p>\n</blockquote>\n<h2 id=\"existing-tooling\">Existing tooling</h2>\n<p>If you don&#39;t feel like creating your own wrapper over <code>fetch</code>, you can use <a\n            href=\"https://github.com/prisma-labs/graphql-request\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"graphql-request\"\n          >\n            graphql-request\n          </a>. This is also a wrapper over the <code>fetch</code> API for making GraphQL requests that doesn&#39;t need much work to start using it. It already handles errors nicely and is isomorphic by default (which some people might not like). The <code>swr</code> GitHub page already provides an example using this.</p>\n<pre class=\"javascript hljs\"><code><span class=\"hljs-keyword\">import</span> { request } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;graphql-request&#x27;</span>\n\n<span class=\"hljs-keyword\">const</span> API = <span class=\"hljs-string\">&#x27;https://api.graph.cool/simple/v1/movies&#x27;</span>\n<span class=\"hljs-keyword\">const</span> fetcher = <span class=\"hljs-function\"><span class=\"hljs-params\">query</span> =&gt;</span> request(API, query)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { data, error } = useSWR(\n    <span class=\"hljs-string\">`{\n      Movie(title: &quot;Inception&quot;) {\n        releaseDate\n        actors {\n          name\n        }\n      }\n    }`</span>,\n    fetcher\n  )\n  <span class=\"hljs-comment\">// ...</span>\n}</code></pre><h2 id=\"conclusion\">Conclusion</h2>\n<p>It feels there&#39;s an artificially high entry level for front-end developers who want to get into the GraphQL world. The fact that Apollo and urql are shown as <em>beginner</em> choices for learning GraphQL can make developers feel like these kinds of tools are actually <em>required</em> to work with a GraphQL API. This is, in fact, not the case; you <strong>can</strong> build a fully capable web application with just the <code>fetch</code> API and some other small libraries for extra features. I can&#39;t think of any small project that would actually require all the features that these big libraries have to offer. To clarify: I&#39;m not saying you shouldn&#39;t use these tools if you want to; I&#39;m saying you don&#39;t need to feel they&#39;re <em>required</em> to build what you want.</p>\n","ttr":7,"slug":"you-dont-need-apollo"}