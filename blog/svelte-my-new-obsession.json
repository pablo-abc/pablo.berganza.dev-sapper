{"attributes":{"title":"Svelte: my new obsession","description":"I gave Svelte a try and ended up rewriting my whole site","banner":"img/blog-pics/2020-04-20.jpg","bannertitle":"Thessaloniki, Greece","tags":["svelte","javascript","programming"],"created":"2020-04-20"},"body":"I admit I am the kind of person who gets immediately obsessed with something if it is new and interesting. That's how I got into [Clojure](https://clojure.org), how I got into [Rust](https://www.rust-lang.org/), and how I got into the topic I'm writing about today: [Svelte](https://svelte.dev/).\n\nSvelte is not a new language I am learning, as it was with Rust and Clojure. It's a JavaScript framework for building single page applications (SPA). Like React, Vue or Angular. Its syntax may remind some people of Vue; but it has a major difference with the typical framework. Svelte does not have a runtime and, unlike the rest, it's not bundled with the rest of your code. Svelte is a compiler. It compiles your components into reactive JavaScript code that modifies the DOM directly. It will produce a small and more performant bundle.\n\n## How does it look?\n\nSvelte tries to stay as close as possible to semantically correct HTML. This means that a simple HTML editor would do the trick for editing a Svelte component.\n\nFor example, the most minimalist component may look like this:\n\n```html\n<p>Hello world!</p>\n```\n\nThat's it! That's a valid Svelte component that the compiler will understand.\n\n## How to make it reactive?\n\nOf course if you were going to write components like that, you would be better off writing plain HTML. The reason you're using a JavaScript framework is because you need a way to handle reactivity in your web application. So we need a way to add JavaScript to our component. As you would do with plain HTML, JavaScript can be added inside a `script` tag like this:\n\n```html\n<script>\n  console.log('Hello world!')\n</script>\n```\n\nIn order to add “state” to our component we just need to declare JavaScript variables:\n\n```html\n<script>\n  let message = 'Hello world!'\n</script>\n```\n\nThese variables can be accessed in the template by using curly braces. This is similar to how Vue does it.\n\n```html\n<script>\n  let messsage = 'Hello world!'\n</script>\n\n<p>{message}</p>\n```\n\nThe `message` variable is reactive. If it were to change for some reason (e.g. an event), the contents of the `p` tag would be immediately updated. For example, we can create an input that updates the content of `message`.\n\nThe template of a Svelte component does not need to be a single element, so we can just add an `input` element right after the `p` element.\n\n```html\n<script>\n  let message = 'Hello world!'\n\n  function onInput(event) {\n    message = event.target.value\n  }\n</script>\n\n<p>{message}</p>\n\n<input value={message} on:input={onInput}>\n```\n\nThis would end up looking like this:\n\n<iframe title=\"text-input\" src=\"https://pablo-abc.github.io/pablo.berganza.dev-examples/svelte-basic-text-input/\"></iframe>\n\nBut this is still too complicated. Svelte provides some “magic” directives in order to make certain operations easier. The `bind` directive helps with two-way data binding.\n\n```html\n<script>\n  let message = 'Hello world!'\n</script>\n\n<p>{message}</p>\n\n<input bind:value={message}>\n```\n\nThis would result in the same output we saw above!\n\n> Svelte only handles reactivity on assignments. This means that array methods like `push` and `pop` won't trigger updates on the components.\n\nSvelte also provides [Handlebars](https://handlebarsjs.com/) like blocks to handle conditional rendering, asynchronicity and loops inside the templates.\n\n## What about styling?\n\nSvelte provides a way to provide scoped styles to your components. As expected, this is done via the `style` HTML tag. Svelte will assign unique classes to each of your component's elements during compilation. You can use any valid CSS inside the tag, but a rollup/webpack plugin may be used to accept your favorite variant (e.g. SASS).\n\n```html\n<h1>Hello world!</h1>\n\n<style>\n  h1 {\n    color: purple;\n  }\n</style>\n```\n\nOn compile time, the `h1` tag will be assigned a class generated by Svelte and a CSS selector for this class will be added to the `h1` on the `style` tag.\n\nIf you need to make the selector global you can wrap it in `:global(...)`. For the example above, if we replaced `h1` for `:global(h1)` it would apply the style globally to all `h1` elements of the project. This can be really useful if your project contains dynamically generated HTML not controlled by Svelte, since Svelte wouldn't be able to assign unique classes to the elements inside it. Something like `div :global(h1)` would select all `h1` elements inside all `div` elements of the component. This can be used to guarantee that the style remains scoped to the component.\n\nOf course, you can always have a global CSS file to handle common styling for all components.\n\n## A more complete example\n\nHere's how a simple to-do app would look like in Svelte:\n\n```html\n<script>\n  let todos = [], value = '';\n  let filter = 'all';\n  // The $: tells Svelte to make the statement reactive.\n  // In this case, the assignment statement to \"filtered\" will be run\n  // everytime \"todos\" changes.\n  $: filtered = todos.filter(todo => {\n    if (filter === 'checked') return todo.checked\n    if (filter === 'unchecked') return !todo.checked\n    return todo\n  })\n  function addTodo() {\n    if (!value) return;\n    todos = [...todos, { value, id: Date.now(), checked: false }];\n    value = '';\n  }\n</script>\n\n<form>\n  <label for=all>\n    <input type=radio id=all value=all bind:group={filter}>\n    All\n  </label>\n  <label for=checked>\n    <input type=radio id=checked value=checked bind:group={filter}>\n    Checked\n  </label>\n  <label for=unchecked>\n    <input type=radio id=unchecked value=unchecked bind:group={filter}>\n    Unchecked\n  </label>\n</form>\n<form on:submit|preventDefault={addTodo}>\n  <input bind:value>\n  <button type=submit>Add Todo</button>\n</form>\n<ul>\n  {#each filtered as todo, i (todo.id)}\n    <li>\n      <input\n        id={todo.id}\n        bind:checked={todo.checked}\n        type=\"checkbox\"\n        >\n      {todo.value}\n    </li>\n  {/each}\n</ul>\n\n<style>\n  label {\n      display: inline-block;\n      margin: 0 10px;\n  }\n  li {\n      list-style: none;\n  }\n</style>\n```\n\n<iframe title=\"todo-app\" height=\"315px\" src=\"https://pablo-abc.github.io/pablo.berganza.dev-examples/svelte-basic-todo-app/\"></iframe>\n\nThis example uses some features I didn't talk about, but the [official tutorial](https://svelte.dev/tutorial/basics \"Svelte official tutorial\") is great if you're interested in learning more.\n\n## Other features\n\nSvelte also provides some other nice features, such as:\n\n* Built-in transitions and animations.\n* Easily access the document's head, window and body.\n* Lifecycles for the components.\n* Global stores.\n* Compatibility with server side rendering.\n* Components can be exported as web components.\n\n## Why rewrite the whole site?\n\nPreviously my site was written using [Perun](https://perun.io). It is a nice static site generator for Clojure that has tons of flexibility, since each step of the generation can be intercepted. But there were certain aspects of the generation that were hard to change or had little documentation. (I am not bashing on Perun, it is a perfectly great tool. I just wanted more freedom).\n\nPerun generates a plain HTML output with no JavaScript. JavaScript needs to be injected manually. Each page is rendered by renderer functions written in Clojure which output HTML. Unless you installed extra packages, there is no built-in support for scoped styling. And, since the generator runs on top of the JVM, the generation of the site was quite slow.\n\nThis site is not written with plain Svelte. It is using [Sapper](https://sapper.svelte.dev). Sapper is a framework for Svelte inspired in [Next.JS](https://nextjs.org) that allows to build server side rendered web applications. It can also export a static site like Next.JS does. This gives you much more freedom on how the site is generated at the cost of a bit more coding. For example, just as I did with Perun, each post's content source is a markdown file. But for Sapper I manually had to write the process the reads the markdown files and generates the HTML. This allowed me to use libraries I am much more familiar with, such as [Marked](https://github.com/markedjs/marked) for markdown parsing and [Highlight.js](https://highlightjs.org/) for code highlighting.\n\nThe resulting site works as an SPA and has some features that I couldn't do previously, some of them:\n\n* Highlighting for GraphQL code.\n* Add working examples of code (such as the ones above).\n* Navigate the whole site without having to do a page reload.\n* Lazy loading of images.\n* Embedding external elements to blog posts, like YouTube videos.\n\nIt also brought some DX improvements such as:\n\n* Reusable components.\n* Scoped CSS styling, which helped with some headaches I had previously due to my lack of CSS knowledge.\n* Much faster generation of the static files.\n* Easily add more interactive elements to the site. (I might add a search bar for my blog posts at a later time).\n* It's easier to follow a more maintainable code structure.\n\nOne downside to using Svelte is its lack of TypeScript support (although this is being worked on).\nAnother downside is that Sapper is still in early development, so I would not recommend it for serious projects. Svelte itself is ready for production, though.\nIt also has a much smaller ecosystem than other mainstream frameworks.\n\n## Conclusion\n\nEven taking into account the downsides mentioned before, Svelte/Sapper has been a joy to work with. In under 20 hours of combined work I managed to rewrite my whole site. Svelte should be an excellent choice for performance critical web applications, and it's syntax is easier to grasp compared to other frameworks. It should definitely not be considered a “toy” framework and I encourage you to add it to your tool set.\n\nAs a little extra, here's the talk that got me excited about Svelte. I recommend everyone with a slight interest on Svelte to watch it.\n\n<div class=\"yt-vid\">\n    <yt-vid alt=\"Rethinking Reactivity - Rich Harris\" src=\"https://www.youtube-nocookie.com/embed/AdNJ3fydeao\" allowfullscreen></yt-vid>\n</div>\n","bodyBegin":12,"frontmatter":"title: 'Svelte: my new obsession'\ndescription: I gave Svelte a try and ended up rewriting my whole site\nbanner: img/blog-pics/2020-04-20.jpg\nbannertitle: Thessaloniki, Greece\ntags:\n    - svelte\n    - javascript\n    - programming","path":"/home/runner/work/pablo.berganza.dev-sapper/pablo.berganza.dev-sapper/src/markdown/blog/2020-04-20-svelte-my-new-obsession/index.en.md","html":"<p>I admit I am the kind of person who gets immediately obsessed with something if it is new and interesting. That&#39;s how I got into <a\n            href=\"https://clojure.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Clojure\"\n          >\n            Clojure\n          </a>, how I got into <a\n            href=\"https://www.rust-lang.org/\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Rust\"\n          >\n            Rust\n          </a>, and how I got into the topic I&#39;m writing about today: <a\n            href=\"https://svelte.dev/\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Svelte\"\n          >\n            Svelte\n          </a>.</p>\n<p>Svelte is not a new language I am learning, as it was with Rust and Clojure. It&#39;s a JavaScript framework for building single page applications (SPA). Like React, Vue or Angular. Its syntax may remind some people of Vue; but it has a major difference with the typical framework. Svelte does not have a runtime and, unlike the rest, it&#39;s not bundled with the rest of your code. Svelte is a compiler. It compiles your components into reactive JavaScript code that modifies the DOM directly. It will produce a small and more performant bundle.</p>\n<h2 id=\"how-does-it-look\">How does it look?</h2>\n<p>Svelte tries to stay as close as possible to semantically correct HTML. This means that a simple HTML editor would do the trick for editing a Svelte component.</p>\n<p>For example, the most minimalist component may look like this:</p>\n<pre class=\"html hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre><p>That&#39;s it! That&#39;s a valid Svelte component that the compiler will understand.</p>\n<h2 id=\"how-to-make-it-reactive\">How to make it reactive?</h2>\n<p>Of course if you were going to write components like that, you would be better off writing plain HTML. The reason you&#39;re using a JavaScript framework is because you need a way to handle reactivity in your web application. So we need a way to add JavaScript to our component. As you would do with plain HTML, JavaScript can be added inside a <code>script</code> tag like this:</p>\n<pre class=\"html hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Hello world!'</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre><p>In order to add “state” to our component we just need to declare JavaScript variables:</p>\n<pre class=\"html hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">'Hello world!'</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre><p>These variables can be accessed in the template by using curly braces. This is similar to how Vue does it.</p>\n<pre class=\"html hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">let</span> messsage = <span class=\"hljs-string\">'Hello world!'</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{message}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre><p>The <code>message</code> variable is reactive. If it were to change for some reason (e.g. an event), the contents of the <code>p</code> tag would be immediately updated. For example, we can create an input that updates the content of <code>message</code>.</p>\n<p>The template of a Svelte component does not need to be a single element, so we can just add an <code>input</code> element right after the <code>p</code> element.</p>\n<pre class=\"html hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">'Hello world!'</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onInput</span>(<span class=\"hljs-params\">event</span>) </span>{\n    message = event.target.value\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{message}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{message}</span> <span class=\"hljs-attr\">on:input</span>=<span class=\"hljs-string\">{onInput}</span>&gt;</span></code></pre><p>This would end up looking like this:</p>\n<iframe title=\"text-input\" src=\"https://pablo-abc.github.io/pablo.berganza.dev-examples/svelte-basic-text-input/\"></iframe>\n\n<p>But this is still too complicated. Svelte provides some “magic” directives in order to make certain operations easier. The <code>bind</code> directive helps with two-way data binding.</p>\n<pre class=\"html hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">'Hello world!'</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{message}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{message}</span>&gt;</span></code></pre><p>This would result in the same output we saw above!</p>\n<blockquote>\n<p>Svelte only handles reactivity on assignments. This means that array methods like <code>push</code> and <code>pop</code> won&#39;t trigger updates on the components.</p>\n</blockquote>\n<p>Svelte also provides <a\n            href=\"https://handlebarsjs.com/\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Handlebars\"\n          >\n            Handlebars\n          </a> like blocks to handle conditional rendering, asynchronicity and loops inside the templates.</p>\n<h2 id=\"what-about-styling\">What about styling?</h2>\n<p>Svelte provides a way to provide scoped styles to your components. As expected, this is done via the <code>style</code> HTML tag. Svelte will assign unique classes to each of your component&#39;s elements during compilation. You can use any valid CSS inside the tag, but a rollup/webpack plugin may be used to accept your favorite variant (e.g. SASS).</p>\n<pre class=\"html hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n  <span class=\"hljs-selector-tag\">h1</span> {\n    <span class=\"hljs-attribute\">color</span>: purple;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre><p>On compile time, the <code>h1</code> tag will be assigned a class generated by Svelte and a CSS selector for this class will be added to the <code>h1</code> on the <code>style</code> tag.</p>\n<p>If you need to make the selector global you can wrap it in <code>:global(...)</code>. For the example above, if we replaced <code>h1</code> for <code>:global(h1)</code> it would apply the style globally to all <code>h1</code> elements of the project. This can be really useful if your project contains dynamically generated HTML not controlled by Svelte, since Svelte wouldn&#39;t be able to assign unique classes to the elements inside it. Something like <code>div :global(h1)</code> would select all <code>h1</code> elements inside all <code>div</code> elements of the component. This can be used to guarantee that the style remains scoped to the component.</p>\n<p>Of course, you can always have a global CSS file to handle common styling for all components.</p>\n<h2 id=\"a-more-complete-example\">A more complete example</h2>\n<p>Here&#39;s how a simple to-do app would look like in Svelte:</p>\n<pre class=\"html hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">let</span> todos = [], value = <span class=\"hljs-string\">''</span>;\n  <span class=\"hljs-keyword\">let</span> filter = <span class=\"hljs-string\">'all'</span>;\n  <span class=\"hljs-comment\">// The $: tells Svelte to make the statement reactive.</span>\n  <span class=\"hljs-comment\">// In this case, the assignment statement to \"filtered\" will be run</span>\n  <span class=\"hljs-comment\">// everytime \"todos\" changes.</span>\n  $: filtered = todos.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">todo</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (filter === <span class=\"hljs-string\">'checked'</span>) <span class=\"hljs-keyword\">return</span> todo.checked\n    <span class=\"hljs-keyword\">if</span> (filter === <span class=\"hljs-string\">'unchecked'</span>) <span class=\"hljs-keyword\">return</span> !todo.checked\n    <span class=\"hljs-keyword\">return</span> todo\n  })\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addTodo</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (!value) <span class=\"hljs-keyword\">return</span>;\n    todos = [...todos, { value, <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">Date</span>.now(), <span class=\"hljs-attr\">checked</span>: <span class=\"hljs-literal\">false</span> }];\n    value = <span class=\"hljs-string\">''</span>;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">all</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">radio</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">all</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">all</span> <span class=\"hljs-attr\">bind:group</span>=<span class=\"hljs-string\">{filter}</span>&gt;</span>\n    All\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">checked</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">radio</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">checked</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">checked</span> <span class=\"hljs-attr\">bind:group</span>=<span class=\"hljs-string\">{filter}</span>&gt;</span>\n    Checked\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">unchecked</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">radio</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">unchecked</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">unchecked</span> <span class=\"hljs-attr\">bind:group</span>=<span class=\"hljs-string\">{filter}</span>&gt;</span>\n    Unchecked\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">on:submit</span>|<span class=\"hljs-attr\">preventDefault</span>=<span class=\"hljs-string\">{addTodo}</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">bind:value</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">submit</span>&gt;</span>Add Todo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  {#each filtered as todo, i (todo.id)}\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n        <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{todo.id}</span>\n        <span class=\"hljs-attr\">bind:checked</span>=<span class=\"hljs-string\">{todo.checked}</span>\n        <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span>\n        &gt;</span>\n      {todo.value}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  {/each}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n  <span class=\"hljs-selector-tag\">label</span> {\n      <span class=\"hljs-attribute\">display</span>: inline-block;\n      <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10px</span>;\n  }\n  <span class=\"hljs-selector-tag\">li</span> {\n      <span class=\"hljs-attribute\">list-style</span>: none;\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre><iframe title=\"todo-app\" height=\"315px\" src=\"https://pablo-abc.github.io/pablo.berganza.dev-examples/svelte-basic-todo-app/\"></iframe>\n\n<p>This example uses some features I didn&#39;t talk about, but the <a\n            href=\"https://svelte.dev/tutorial/basics\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Svelte official tutorial\"\n          >\n            official tutorial\n          </a> is great if you&#39;re interested in learning more.</p>\n<h2 id=\"other-features\">Other features</h2>\n<p>Svelte also provides some other nice features, such as:</p>\n<ul>\n<li>Built-in transitions and animations.</li>\n<li>Easily access the document&#39;s head, window and body.</li>\n<li>Lifecycles for the components.</li>\n<li>Global stores.</li>\n<li>Compatibility with server side rendering.</li>\n<li>Components can be exported as web components.</li>\n</ul>\n<h2 id=\"why-rewrite-the-whole-site\">Why rewrite the whole site?</h2>\n<p>Previously my site was written using <a\n            href=\"https://perun.io\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Perun\"\n          >\n            Perun\n          </a>. It is a nice static site generator for Clojure that has tons of flexibility, since each step of the generation can be intercepted. But there were certain aspects of the generation that were hard to change or had little documentation. (I am not bashing on Perun, it is a perfectly great tool. I just wanted more freedom).</p>\n<p>Perun generates a plain HTML output with no JavaScript. JavaScript needs to be injected manually. Each page is rendered by renderer functions written in Clojure which output HTML. Unless you installed extra packages, there is no built-in support for scoped styling. And, since the generator runs on top of the JVM, the generation of the site was quite slow.</p>\n<p>This site is not written with plain Svelte. It is using <a\n            href=\"https://sapper.svelte.dev\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Sapper\"\n          >\n            Sapper\n          </a>. Sapper is a framework for Svelte inspired in <a\n            href=\"https://nextjs.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Next.JS\"\n          >\n            Next.JS\n          </a> that allows to build server side rendered web applications. It can also export a static site like Next.JS does. This gives you much more freedom on how the site is generated at the cost of a bit more coding. For example, just as I did with Perun, each post&#39;s content source is a markdown file. But for Sapper I manually had to write the process the reads the markdown files and generates the HTML. This allowed me to use libraries I am much more familiar with, such as <a\n            href=\"https://github.com/markedjs/marked\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Marked\"\n          >\n            Marked\n          </a> for markdown parsing and <a\n            href=\"https://highlightjs.org/\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Highlight.js\"\n          >\n            Highlight.js\n          </a> for code highlighting.</p>\n<p>The resulting site works as an SPA and has some features that I couldn&#39;t do previously, some of them:</p>\n<ul>\n<li>Highlighting for GraphQL code.</li>\n<li>Add working examples of code (such as the ones above).</li>\n<li>Navigate the whole site without having to do a page reload.</li>\n<li>Lazy loading of images.</li>\n<li>Embedding external elements to blog posts, like YouTube videos.</li>\n</ul>\n<p>It also brought some DX improvements such as:</p>\n<ul>\n<li>Reusable components.</li>\n<li>Scoped CSS styling, which helped with some headaches I had previously due to my lack of CSS knowledge.</li>\n<li>Much faster generation of the static files.</li>\n<li>Easily add more interactive elements to the site. (I might add a search bar for my blog posts at a later time).</li>\n<li>It&#39;s easier to follow a more maintainable code structure.</li>\n</ul>\n<p>One downside to using Svelte is its lack of TypeScript support (although this is being worked on).\nAnother downside is that Sapper is still in early development, so I would not recommend it for serious projects. Svelte itself is ready for production, though.\nIt also has a much smaller ecosystem than other mainstream frameworks.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Even taking into account the downsides mentioned before, Svelte/Sapper has been a joy to work with. In under 20 hours of combined work I managed to rewrite my whole site. Svelte should be an excellent choice for performance critical web applications, and it&#39;s syntax is easier to grasp compared to other frameworks. It should definitely not be considered a “toy” framework and I encourage you to add it to your tool set.</p>\n<p>As a little extra, here&#39;s the talk that got me excited about Svelte. I recommend everyone with a slight interest on Svelte to watch it.</p>\n<div class=\"yt-vid\">\n    <yt-vid alt=\"Rethinking Reactivity - Rich Harris\" src=\"https://www.youtube-nocookie.com/embed/AdNJ3fydeao\" allowfullscreen></yt-vid>\n</div>\n","ttr":9,"slug":"svelte-my-new-obsession"}