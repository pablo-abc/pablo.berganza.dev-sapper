<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <link href=apple-icon-57x57.png rel=apple-touch-icon sizes=57x57> <link href=apple-icon-60x60.png rel=apple-touch-icon sizes=60x60> <link href=apple-icon-72x72.png rel=apple-touch-icon sizes=72x72> <link href=apple-icon-76x76.png rel=apple-touch-icon sizes=76x76> <link href=apple-icon-114x114.png rel=apple-touch-icon sizes=114x114> <link href=apple-icon-120x120.png rel=apple-touch-icon sizes=120x120> <link href=apple-icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=apple-icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=apple-icon-180x180.png rel=apple-touch-icon sizes=180x180> <link href=android-icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=favicon-32x32.png rel=icon sizes=32x32 type=image/png> <link href=favicon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=favicon-16x16.png rel=icon sizes=16x16 type=image/png> <link href=manifest.json rel=manifest> <meta content=#E34495 name=msapplication-TileColor> <meta content=ms-icon-144x144.png name=msapplication-TileImage> <meta content=#E34495 name=theme-color> <base href=/ > <link href=overpass.css rel=stylesheet> <link href=dracula.css rel=stylesheet> <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=client/main.1227856807.css rel=stylesheet><link href=client/client.e8b9dac7.css rel=stylesheet><link href=client/Blog.b35d170b.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>GraphQL: ¿Vale la pena el cambio? | Pablo Berganza</title><meta content="Pablo Berganza" name=author><meta content="Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo" name=description><meta content="GraphQL: ¿Vale la pena el cambio? | Pablo Berganza" itemdrop=name><meta content="Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo" itemdrop=description><meta content=https://pablo-abc.github.io/pablo.berganza.dev-sapper/img/blog-pics/2019-06-11.jpg name=twitter:image:src> <meta content=https://pablo-abc.github.io/pablo.berganza.dev-sapper/img/blog-pics/2019-06-11.jpg property=og:image><meta content=summary name=twitter:card><meta content="GraphQL: ¿Vale la pena el cambio? | Pablo Berganza" name=twitter:title><meta content="Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo" name=twitter:description><meta content=Pablo_ABC name=twitter:site><meta content=Pablo_ABC name=twitter:creator><meta content="GraphQL: ¿Vale la pena el cambio? | Pablo Berganza" property=og:title><meta content=https://pablo-abc.github.io/pablo.berganza.dev-sapper/es/blog/2019-06-11-graphql-is-it-worth-the-switch property=og:url><meta content="Pablo Berganza" property=og:site_name><meta content="Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo" property=og:description><meta content=es property=og:locale><meta content=1441268341 property=fb:admins><meta content=2097322913669232 property=fb:app_id><meta content=article property=og:type><meta content="Pablo Berganza" property=article:author> <meta content=2019-06-11 property=article:published_time><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <header class=svelte-19funi><nav class=svelte-j1tcfr><div class="svelte-j1tcfr left-nav"><a href=./es/ class=svelte-j1tcfr id=logo><span class=svelte-j1tcfr>Pablo</span> <span class=svelte-j1tcfr>Berganza</span></a> <div class="svelte-j1tcfr nav-items"><a href=es/blog class=nav-item rel=prefetch id=blog-nav>Blog </a> | <a href=es/contact class=nav-item id=contact-nav>Contáctame</a></div></div> <div class="svelte-j1tcfr right-nav"><a href=blog/2019-06-11-graphql-is-it-worth-the-switch rel=prefetch>en</a> <a href=https://github.com/pablo-abc class="nav-item sm svelte-1r50gsv" rel="noopener noreferrer" aria-label=GitHub target=_blank title=GitHub><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 496 512" xmlns=http://www.w3.org/2000/svg><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" fill=currentColor></path></svg> </a> <a href=https://www.instagram.com/berganzapablo/ class="nav-item sm svelte-1r50gsv" rel="noopener noreferrer" aria-label=Instagram target=_blank title=Instagram><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z" fill=currentColor></path></svg> </a> <a href=https://www.linkedin.com/in/PabloABC class="nav-item sm svelte-1r50gsv" rel="noopener noreferrer" aria-label=LinkedIn target=_blank title=LinkedIn><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z" fill=currentColor></path></svg> </a> <a href=https://twitter.com/Pablo_ABC class="nav-item sm svelte-1r50gsv" rel="noopener noreferrer" aria-label=Twitter target=_blank title=Twitter><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 512 512" xmlns=http://www.w3.org/2000/svg><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z" fill=currentColor></path></svg> </a></div> </nav></header> <main class=svelte-19funi> <article id=blog><header class="svelte-182akrk title"><h1 class=svelte-182akrk>GraphQL: ¿Vale la pena el cambio?</h1> <h4 class="svelte-182akrk introduction">Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo</h4></header> <img alt="Peloponeso, Grecia" class="banner svelte-ol1t6h" src=img/blog-pics/2019-06-11-placeholder.jpg title="Peloponeso, Grecia"> <div class="svelte-182akrk ttr-created"><span class=ttr><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 512 512" xmlns=http://www.w3.org/2000/svg><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z" fill=currentColor></path></svg> 12 min </span> <span class=created><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z" fill=currentColor></path></svg> 2019-06-11</span></div> <div class="svelte-182akrk tag-links">Tags: <a href=es/blog/tags/graphql class="svelte-182akrk tag-link">graphql </a><a href=es/blog/tags/rest class="svelte-182akrk tag-link">rest </a><a href=es/blog/tags/api class="svelte-182akrk tag-link">api </a></div> <section class="svelte-182akrk content"><p>Este último año trabajando como desarrollador web he estado, básicamente, respirando <a href=https://es.wikipedia.org/wiki/Transferencia_de_Estado_Representacional>REST</a> todos los días. Aunque no es tanto tiempo, ha sido más que suficiente para apreciar la simplicidad sobre SOAP, y para odiar los momentos en que los requerimientos del cliente o otras situaciones te fuerzan a escribir endpoints que no son <a href=https://restfulapi.net/rest-architectural-constraints/ >RESTful</a>. Aunque REST es ya un estándar para crear APIs web modernas, hace un par de años ha habido un competidor del cual no me había forzado a investigar todavía: <a href=https://graphql.org>GraphQL</a>. Pero eso ha cambiado y ya he experimentado un poco implementándolo en el cliente y en el servidor.</p> <p>Según <a href=https://graphql.org>graphql.org</a>, "GraphQL es un lenguage de consulta para APIs y un sistema en tiempo de ejecución para cumplir esas consultas con tu información existente". Un servidor que esté implementando la especificación de GraphQL debería poder recibir una consulta enviada por el cliente, conteniendo una descripción de la infromación específica que el cliente necesita, y debería poder proveer ésta información así como el cliente la pidió.</p> <p>Pero antes de hablar más sobre GraphQL, veamos qué es tan bueno sobre REST.</p> <h2 id=rest>REST</h2> <p>REST es un estilo de arquitectura que define una serie de reglas para construir servicios web. Cuando alguien habla de un API que sigue la arquitectura propuesta por REST, suelen referirse a un servidor que se comunica con el cliente por medio del protocolo HTTP. El cliente se aprovecha de los distintos métodos HTTP (GET, POST, PUT, PATCH, DELETE) para hacer consultas a direcciones en el API que representan recursos.</p> <p>Algunos ejemplos de endpoints REST son:</p> <pre class="hljs http"><code>GET http://api.example.com/accounts

GET http://api.example.com/accounts/8326

GET http://api.example.com/accounts/8326/posts

GET http://api.example.com/posts/4123/comments</code></pre><p>Dependiendo de qué método se utilice para llamar al endpoint, se aplicará una distinta operación al recursos.</p> <table> <thead> <tr> <th>MÉTODO</th> <th>ENDPOINT</th> <th>DESCRIPCIÓN</th> <th>ESTADO DE RESPUESTA</th> </tr> </thead> <tr> <td>GET</td> <td>/resources</td> <td>Obtener una lista de elementos</td> <td>200</td> </tr> <tr> <td>GET</td> <td>/resources/{id}</td> <td>Obtener un solo elemento</td> <td>200, 404</td> </tr> <tr> <td>POST</td> <td>/resources</td> <td>Crear un elemento</td> <td>201, 400</td> </tr> <tr> <td>PUT</td> <td>/resources/{id}</td> <td>Modificar un elemento completo</td> <td>200, 400</td> </tr> <tr> <td>PATCH</td> <td>/resources/{id}</td> <td>Modificar campos específicos del elemento</td> <td>200, 400</td> </tr> <tr> <td>DELETE</td> <td>/resources/{id}</td> <td>Eliminar un elemento</td> <td>204, 200, 404</td> </tr> </table> <p>Esto nos da una limpia y predecible interfaz para operar sobre los recursos en el servidor.</p> <p>Como se ve en los endpoints del ejemplo anterior, los endpoints en una arquitectura REST pueden seguir una estructura jerárquica. Por ejemplo, si se hiciera una consulta con el método POST al endpoint <code>/accounts/8326/posts</code>, ésto debería significar que se está creando una publicación (post) que pertenece a la cuenta (account) con id 8326.</p> <p>He hablado sobre como un API REST debe verse para el cliente, pero éstas características no son suficientes para que una API pueda ser considerada una API REST. Para poder ser clasificada como tal, debe seguir las siguientes seis reglas:</p> <ul> <li><strong>Interfaz uniforme</strong>: Una API REST debe tener una interfaz bien definida y consistente. Esta interfaz debe seguirse casi religiosamente en todos los recursos expuestos por el API. Debe tener consistentes convenciones de nombramiento, formato de datos, etc.</li> <li><strong>Cliente-servidor</strong>: Debe haber una separación clara entre cliente y servidor.</li> <li><strong>Sin estado</strong>: Todas las interacciones del cliente con el servidor no deben contener estado. Esto significa que el servidor debe asumir que toda consulta hecha a éste es completamente nueva, sin conocimiento alguno de estados anteriores del cliente.</li> <li><strong>Cacheable</strong>: Si un endpoint REST es suficientemente estable, este podría ser puesto en cache, ya sea en el cliente o servidor. Los endpoints que puedan ser puestos en el cache deben explícitamente indicar esto.</li> <li><strong>Sistema en capas</strong>: La arquitectura del sistema puede estar en capaz, es decir, el cliente puede estar interactuando con distintos servidores comportándose como que si estuviera interactuando diréctamente con el API REST.</li> <li><strong>Código a pedido</strong>: Esta es la única regla opcional de la arquitectura REST. Indica que, cuando sea necesario, un endpoint REST puede retornar código ejecutable como respuesta a una consulta del cliente.</li> </ul> <p>Éstas reglas nos traen varios beneficios:</p> <ul> <li>Una interfaz uniforme permite que el cliente pueda navegar intuitivamente tu API cuando empiecen a acostumbrarse a este.</li> <li>Una interfaz bien definida hace más fácil la organización del código del sevidor en base a recursos.</li> <li>Una arquitectura cliente-servidor permite a ambos, el cliente y el servidor, poder evolucionar independientemente.</li> <li>Al no mantener estado del cliente un servidor tiene, teóricamente, una escalabilidad ilimitada. Puede replicarse indefinidamente cuando se requieran altos recursos sin afectar la interacción con el cliente.</li> <li>Mantener un cache de algunos endpoints ayuda a reducir la carga del servidor.</li> <li>Un sistema en capas permite al cliente pasar por intermediarios (ej. por motivos de autenticación) mientras sigue interactuando de la misma forma con el servidor.</li> </ul> <p>Aunque el formato de dato más usado en APIs REST es JSON, si es necesario se puede utilizar otros formatos (ej. XML). Además, aunque la mayoría de APIs REST disponibles públicamente son servidas a través del protocolo HTTP, un API REST podría ser servida por un protocolo distinto.</p> <p>Como se puede ver, una API REST desarrollada propiamente viene con muchos beneficios, pero también hay unas cuantas desventajas:</p> <ul> <li><p>Cómo no hay un estándar único definido sobre como se debe comportar un API REST (además de las seis reglas mencionadas), muchas decisiones del diseño quedan a responsabilidad del desarrollador. Esto significa que no se podrá interactuar necesariamente de la misma forma con dos distintas APIs REST.</p> </li> <li><p>A menos que filtros hayan sido implementados en el servidor, un endpoint REST puede returnar mucha más información de la que el cliente necesita.</p> </li> <li><p>Debido a que los endpoints REST son divididos por recursos, para poder popular completamente una vista del cliente es probable que se necesite hacer varias consultas al servidor.</p> </li> <li><p>La consistencia es difícil. El equipo de desarrollo debe tratar activamente de mantener la consistencia, esto significa más esfuerzo a la hora de desarrollar. Es fácil agregar inconsistencias al servidor.</p> </li> <li><p>Fechas límite, requerimientos del cliente, etc. pueden llevar a romper algunas de las reglas de REST. Esto podría llevar a una mezcla de distintas arquitecturas (ej. RPC).</p> <p>Esto muestra que construir una verdadera API REST no es tarea fácil. Hay varios agujeros en los que el equipo de desarrollo puede caer, haciendo que el resultado final no sea una API REST, y que se pierdan algunos de los beneficios proporcionados por el cumplimiento de las reglas de REST.</p> <p>Entonces, ¿qué nos ofrece GraphQL?</p> </li> </ul> <h2 id=graphql>GraphQL</h2> <p>Como se ha dicho antes, GraphQL es descrito como un lenguaje de consultas para APIs. A diferencia de REST, GraphQL define un solo endpoint que acepta toda las operaciones hacia el servidor en un parámetro llamado "query". Las consultas son generalmente echas utilizando el método POST en el endpoint de GraphQL, pero la especificación permite utilizar el método GET para operaciones de solo lectura.</p> <p>Hay dos tipos de llamadas que puedes hacer a un API GraphQL: consultas y mutaciones. Una consulta se ve de la siguiente forma:</p> <pre class="hljs javascript"><code>{
  post(id:<span class=hljs-string>"1"</span>) {
    id
    title
    content
    author {
      id
      email
    }
}</code></pre><p>Esto significa que debe haber un esquema de tipo consulta con el nombre "post" definido en el servidor. Esta consulta está pidiendo el id, título, contenido, el id del autor y el correo del autor de la publicación con id "1". Si es encontrada, la respuesta seguirá la misma estructura descrita en la consulta. Una consulta de GraphQL es análoga a realizar una llamada con GET a un endpoint REST.</p> <p>Una mutación en GraphQL se ve de la siguiente forma:</p> <pre class="hljs javascript"><code>mutation {
  createAccount(
    email:<span class=hljs-string>"pablo@berganza.dev"</span>
    <span class=hljs-attr>password</span>:<span class=hljs-string>"super secure password"</span>
  ) {
    id
    email
  }
}</code></pre><p>Esto asume que hay un esquema de tipo mutación llamado "createAccount" definido en el servidor. Esta mutación está pidiéndole al servidor que cree una cuenta con el email y la contraseña especificadas, y al terminar la creación que retorne su id y su email.</p> <p>GraphQL no debería considerarse un estilo de arquitectura. Es, más bien, una serie de herramientas que facilitan el desarrollo de APIs tipo RPC (ya que estás llamando funciones en el servidor). Aún así, una API GraphQL comparte varias características con un API REST:</p> <ul> <li>Hay una clara separación entre cliente y servidor.</li> <li>El servidor no mantiene un estado.</li> <li>Aunque la mayoría de APIs GraphQL son servidas sobre HTTP, podría ser servida sobre un protocolo distinto.</li> </ul> <p>A parte de esto, un API GraphQL tiene otras ventajas sobre un API REST:</p> <ul> <li>Una interfaz consistente con el cliente, ya que la comunicación cliente-servidor se hace utilizando un lenguage de consulta ya definido.</li> <li>La documentación es auto-generada. Cuando los esquemas son definidos, estos está disponibles para que el cliente las vea. También es posible agregar "docstrings" a los esquemas para poder explicarlos más a fondo.</li> <li>Las herramientas disponibles proveen una muy agradable experiencia de desarrollo. Herramientas como Graphiql y GraphQL Playground pueden hacer explorar los esquemas de un API GraphQL muy fácil, y muchas librerías para el cliente, como Apollo, pueden proveer otras herramientas para agregar funcionalidad al cliente.</li> <li>Desde el momento en que los esquemas son definidos hay un contrato entre el cliente y el servidor. Los esquemas incluyen las propiedades y los tipos de datos esperados en entrada y salida. Más propiedades pueden ser agregadas después al esquema, pero no se recomienda remover propiedades que ya están definidas.</li> <li>La barrera de entrada para diseñar un API GraphQL comparada a un API REST es mucho más baja.</li> <li>Ya hay una vasta cantidad de implementaciones de la exacta especificación de GraphQL en la mayoría de lenguages de programación grandes, esto permite una interacción consistente entre distintas APIs GraphQL.</li> <li>Reduce considerablemente la cantidad de llamadas al servidor, ya que toda la información puede ser pedida, potencialmente, con una sola llamada.</li> </ul> <p>Pero obviamente no hay solo ventajas en el mundo de GraphQL. Estamos perdiendo algunas de las ventajas proveídas por la arquitectura REST cuando implementamos un API GraphQL, y además hay otras desventajas:</p> <ul> <li>Aunque es generalmente servida sobre HTTP, se pierde muchos beneficios proporcionados por dicho protocolo como caching, limitación de peticiones, etc. Esto reduce su escalabilidad potencialmente.</li> <li>Un API GraphQL es potencialmente menos eficiente que un API REST. Debido a la impredecible complejidad de las llamadas hechas al servidor, es probable que un solo llamado al servidor implique operaciones N+1.</li> <li>Al ser publicada en el 2015 (y al iniciar desarrollo en el 2012) se puede argumentar que el cosistema todavía no es maduro y hay posibilidad para considerables cambios en el futuro.</li> <li>Para aplicaciones sencillas las llamadas pueden hacerse utilizando fetch API o librerías como Axios. Pero si la aplicación crece, una librería de GraphQL (como Apollo Client) puede ser necesitada. Esto aumentaría el tamaño del bundle de JavaScript.</li> <li>Puede aumentar considerablemente la complejidad del código del servidor cuando optimizaciones son requeridas.</li> <li>GraphQL suele retornar siempre un estado de 200. Como se pueden enviar varias consultas/mutaciones en un solo llamado, y algunas de estas pueden tener éxito y otras fallar de distinta forma, el manejo de errores puede volverse complicado del lado del cliente.</li> </ul> <p>Hay varias otras características en la especificación de GraphQL sobre las que no escribí, como fragments, consultas y mutaciones nombradas, variables, etc. Así que puedes revisar <a href=https://graphql.org>graphql.org</a> para aprender más sobre esto si te ha interesado.</p> <h2 id=conclusión>Conclusión</h2> <p>Entonces, ¿vale la pena el cambio? Cómo todo debate entre tecnologías, la respuesta es si y no. Hay casos de uso para ambos, GraphQL y REST. Por ejemplo, una API GraphQL puede ser útil cuando el desarrollo necesita iniciar antes que los requerimientos del cliente estén propiamente definidos, y puede ayudar a mantener un API consistente sin mucho esfuerzo. Al final, siempre se debe evaluar las ventajas y desventajas, y elegir la herramienta adecuada para el trabajo.</p> </section> <footer><ul class="svelte-dw82cf share-buttons"><li class=svelte-dw82cf>Compártelo:</li> <li class=svelte-dw82cf><a href="https://www.facebook.com/sharer/sharer.php?u=https://pablo-abc.github.io/pablo.berganza.dev-sapper/2019-06-11-graphql-is-it-worth-the-switch&quote=Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo" target=_blank title="Share on Facebook"><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h137.25V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.27c-30.81 0-40.42 19.12-40.42 38.73V256h68.78l-11 71.69h-57.78V480H400a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48z" fill=currentColor></path></svg> <span class="sr-only svelte-n6z7xj">Share on Facebook</span> </a></li> <li class=svelte-dw82cf><a href="https://twitter.com/intent/tweet?source=https://pablo-abc.github.io/pablo.berganza.dev-sapper/2019-06-11-graphql-is-it-worth-the-switch&text=Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo:%20https://pablo-abc.github.io/pablo.berganza.dev-sapper/2019-06-11-graphql-is-it-worth-the-switch&via=Pablo_ABC" target=_blank title=Tweet><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z" fill=currentColor></path></svg> <span class="sr-only svelte-n6z7xj">Tweet</span> </a></li> <li class=svelte-dw82cf><a href="https://getpocket.com/save?url=https://pablo-abc.github.io/pablo.berganza.dev-sapper/2019-06-11-graphql-is-it-worth-the-switch&title=GraphQL: ¿Vale la pena el cambio?" target=_blank title="Add to Pocket"><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M407.6 64h-367C18.5 64 0 82.5 0 104.6v135.2C0 364.5 99.7 464 224.2 464c124 0 223.8-99.5 223.8-224.2V104.6c0-22.4-17.7-40.6-40.4-40.6zm-162 268.5c-12.4 11.8-31.4 11.1-42.4 0C89.5 223.6 88.3 227.4 88.3 209.3c0-16.9 13.8-30.7 30.7-30.7 17 0 16.1 3.8 105.2 89.3 90.6-86.9 88.6-89.3 105.5-89.3 16.9 0 30.7 13.8 30.7 30.7 0 17.8-2.9 15.7-114.8 123.2z" fill=currentColor></path></svg> <span class="sr-only svelte-n6z7xj">Add to Pocket</span> </a></li> <li class=svelte-dw82cf><a href="http://www.reddit.com/submit?url=https://pablo-abc.github.io/pablo.berganza.dev-sapper/2019-06-11-graphql-is-it-worth-the-switch&title=GraphQL: ¿Vale la pena el cambio?" target=_blank title="Submit to Reddit"><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M283.2 345.5c2.7 2.7 2.7 6.8 0 9.2-24.5 24.5-93.8 24.6-118.4 0-2.7-2.4-2.7-6.5 0-9.2 2.4-2.4 6.5-2.4 8.9 0 18.7 19.2 81 19.6 100.5 0 2.4-2.3 6.6-2.3 9 0zm-91.3-53.8c0-14.9-11.9-26.8-26.5-26.8-14.9 0-26.8 11.9-26.8 26.8 0 14.6 11.9 26.5 26.8 26.5 14.6 0 26.5-11.9 26.5-26.5zm90.7-26.8c-14.6 0-26.5 11.9-26.5 26.8 0 14.6 11.9 26.5 26.5 26.5 14.9 0 26.8-11.9 26.8-26.5 0-14.9-11.9-26.8-26.8-26.8zM448 80v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V80c0-26.5 21.5-48 48-48h352c26.5 0 48 21.5 48 48zm-99.7 140.6c-10.1 0-19 4.2-25.6 10.7-24.1-16.7-56.5-27.4-92.5-28.6l18.7-84.2 59.5 13.4c0 14.6 11.9 26.5 26.5 26.5 14.9 0 26.8-12.2 26.8-26.8 0-14.6-11.9-26.8-26.8-26.8-10.4 0-19.3 6.2-23.8 14.9l-65.7-14.6c-3.3-.9-6.5 1.5-7.4 4.8l-20.5 92.8c-35.7 1.5-67.8 12.2-91.9 28.9-6.5-6.8-15.8-11-25.9-11-37.5 0-49.8 50.4-15.5 67.5-1.2 5.4-1.8 11-1.8 16.7 0 56.5 63.7 102.3 141.9 102.3 78.5 0 142.2-45.8 142.2-102.3 0-5.7-.6-11.6-2.1-17 33.6-17.2 21.2-67.2-16.1-67.2z" fill=currentColor></path></svg> <span class="sr-only svelte-n6z7xj">Submit to Reddit</span> </a></li> <li class=svelte-dw82cf><a href="http://www.linkedin.com/shareArticle?mini=true&url=https://pablo-abc.github.io/pablo.berganza.dev-sapper/2019-06-11-graphql-is-it-worth-the-switch&title=GraphQL: ¿Vale la pena el cambio?&summary=Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo&source=https://pablo-abc.github.io/pablo.berganza.dev-sapper/2019-06-11-graphql-is-it-worth-the-switch" target=_blank title="Share on LinkedIn"><svg aria-hidden=true class="fa-svelte svelte-p8vizn" role=img viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z" fill=currentColor></path></svg> <span class="sr-only svelte-n6z7xj">Share on LinkedIn</span> </a></li> </ul></footer> </article> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,null,(function(a,b,c,d,e,f,g,h){return {blog:{attributes:{title:a,introduction:b,created:c,banner:d,bannertitle:e,tags:[f,g,h]},body:"Este último año trabajando como desarrollador web he estado, básicamente, respirando [REST](https:\u002F\u002Fes.wikipedia.org\u002Fwiki\u002FTransferencia_de_Estado_Representacional) todos los días. Aunque no es tanto tiempo, ha sido más que suficiente para apreciar la simplicidad sobre SOAP, y para odiar los momentos en que los requerimientos del cliente o otras situaciones te fuerzan a escribir endpoints que no son [RESTful](https:\u002F\u002Frestfulapi.net\u002Frest-architectural-constraints\u002F). Aunque REST es ya un estándar para crear APIs web modernas, hace un par de años ha habido un competidor del cual no me había forzado a investigar todavía: [GraphQL](https:\u002F\u002Fgraphql.org). Pero eso ha cambiado y ya he experimentado un poco implementándolo en el cliente y en el servidor.\n\nSegún [graphql.org](https:\u002F\u002Fgraphql.org), \"GraphQL es un lenguage de consulta para APIs y un sistema en tiempo de ejecución para cumplir esas consultas con tu información existente\". Un servidor que esté implementando la especificación de GraphQL debería poder recibir una consulta enviada por el cliente, conteniendo una descripción de la infromación específica que el cliente necesita, y debería poder proveer ésta información así como el cliente la pidió.\n\nPero antes de hablar más sobre GraphQL, veamos qué es tan bueno sobre REST.\n\n## REST\n\nREST es un estilo de arquitectura que define una serie de reglas para construir servicios web. Cuando alguien habla de un API que sigue la arquitectura propuesta por REST, suelen referirse a un servidor que se comunica con el cliente por medio del protocolo HTTP. El cliente se aprovecha de los distintos métodos HTTP (GET, POST, PUT, PATCH, DELETE) para hacer consultas a direcciones en el API que representan recursos.\n\nAlgunos ejemplos de endpoints REST son:\n\n```http\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\n\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\u002F8326\n\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\u002F8326\u002Fposts\n\nGET http:\u002F\u002Fapi.example.com\u002Fposts\u002F4123\u002Fcomments\n```\n\nDependiendo de qué método se utilice para llamar al endpoint, se aplicará una distinta operación al recursos.\n\n| MÉTODO | ENDPOINT        | DESCRIPCIÓN                               | ESTADO DE RESPUESTA |\n|--------|-----------------|-------------------------------------------|---------------------|\n| GET    | \u002Fresources      | Obtener una lista de elementos            | 200                 |\n| GET    | \u002Fresources\u002F{id} | Obtener un solo elemento                  | 200, 404            |\n| POST   | \u002Fresources      | Crear un elemento                         | 201, 400            |\n| PUT    | \u002Fresources\u002F{id} | Modificar un elemento completo            | 200, 400            |\n| PATCH  | \u002Fresources\u002F{id} | Modificar campos específicos del elemento | 200, 400            |\n| DELETE | \u002Fresources\u002F{id} | Eliminar un elemento                      | 204, 200, 404       |\n\nEsto nos da una limpia y predecible interfaz para operar sobre los recursos en el servidor.\n\nComo se ve en los endpoints del ejemplo anterior, los endpoints en una arquitectura REST pueden seguir una estructura jerárquica. Por ejemplo, si se hiciera una consulta con el método POST al endpoint `\u002Faccounts\u002F8326\u002Fposts`, ésto debería significar que se está creando una publicación (post) que pertenece a la cuenta (account) con id 8326.\n\nHe hablado sobre como un API REST debe verse para el cliente, pero éstas características no son suficientes para que una API pueda ser considerada una API REST. Para poder ser clasificada como tal, debe seguir las siguientes seis reglas:\n\n  * **Interfaz uniforme**: Una API REST debe tener una interfaz bien definida y consistente. Esta interfaz debe seguirse casi religiosamente en todos los recursos expuestos por el API. Debe tener consistentes convenciones de nombramiento, formato de datos, etc.\n  * **Cliente-servidor**: Debe haber una separación clara entre cliente y servidor.\n  * **Sin estado**: Todas las interacciones del cliente con el servidor no deben contener estado. Esto significa que el servidor debe asumir que toda consulta hecha a éste es completamente nueva, sin conocimiento alguno de estados anteriores del cliente.\n  * **Cacheable**: Si un endpoint REST es suficientemente estable, este podría ser puesto en cache, ya sea en el cliente o servidor. Los endpoints que puedan ser puestos en el cache deben explícitamente indicar esto.\n  * **Sistema en capas**: La arquitectura del sistema puede estar en capaz, es decir, el cliente puede estar interactuando con distintos servidores comportándose como que si estuviera interactuando diréctamente con el API REST.\n  * **Código a pedido**: Esta es la única regla opcional de la arquitectura REST. Indica que, cuando sea necesario, un endpoint REST puede retornar código ejecutable como respuesta a una consulta del cliente.\n\nÉstas reglas nos traen varios beneficios:\n\n  * Una interfaz uniforme permite que el cliente pueda navegar intuitivamente tu API cuando empiecen a acostumbrarse a este.\n  * Una interfaz bien definida hace más fácil la organización del código del sevidor en base a recursos.\n  * Una arquitectura cliente-servidor permite a ambos, el cliente y el servidor, poder evolucionar independientemente.\n  * Al no mantener estado del cliente un servidor tiene, teóricamente, una escalabilidad ilimitada. Puede replicarse indefinidamente cuando se requieran altos recursos sin afectar la interacción con el cliente.\n  * Mantener un cache de algunos endpoints ayuda a reducir la carga del servidor.\n  * Un sistema en capas permite al cliente pasar por intermediarios (ej. por motivos de autenticación) mientras sigue interactuando de la misma forma con el servidor.\n\nAunque el formato de dato más usado en APIs REST es JSON, si es necesario se puede utilizar otros formatos (ej. XML). Además, aunque la mayoría de APIs REST disponibles públicamente son servidas a través del protocolo HTTP, un API REST podría ser servida por un protocolo distinto.\n\nComo se puede ver, una API REST desarrollada propiamente viene con muchos beneficios, pero también hay unas cuantas desventajas:\n\n  * Cómo no hay un estándar único definido sobre como se debe comportar un API REST (además de las seis reglas mencionadas), muchas decisiones del diseño quedan a responsabilidad del desarrollador. Esto significa que no se podrá interactuar necesariamente de la misma forma con dos distintas APIs REST.\n  * A menos que filtros hayan sido implementados en el servidor, un endpoint REST puede returnar mucha más información de la que el cliente necesita.\n  * Debido a que los endpoints REST son divididos por recursos, para poder popular completamente una vista del cliente es probable que se necesite hacer varias consultas al servidor.\n  * La consistencia es difícil. El equipo de desarrollo debe tratar activamente de mantener la consistencia, esto significa más esfuerzo a la hora de desarrollar. Es fácil agregar inconsistencias al servidor.\n  * Fechas límite, requerimientos del cliente, etc. pueden llevar a romper algunas de las reglas de REST. Esto podría llevar a una mezcla de distintas arquitecturas (ej. RPC).\n\n  Esto muestra que construir una verdadera API REST no es tarea fácil. Hay varios agujeros en los que el equipo de desarrollo puede caer, haciendo que el resultado final no sea una API REST, y que se pierdan algunos de los beneficios proporcionados por el cumplimiento de las reglas de REST.\n\n  Entonces, ¿qué nos ofrece GraphQL?\n\n## GraphQL\n\nComo se ha dicho antes, GraphQL es descrito como un lenguaje de consultas para APIs. A diferencia de REST, GraphQL define un solo endpoint que acepta toda las operaciones hacia el servidor en un parámetro llamado \"query\". Las consultas son generalmente echas utilizando el método POST en el endpoint de GraphQL, pero la especificación permite utilizar el método GET para operaciones de solo lectura.\n\nHay dos tipos de llamadas que puedes hacer a un API GraphQL: consultas y mutaciones. Una consulta se ve de la siguiente forma:\n\n```javascript\n{\n  post(id:\"1\") {\n    id\n    title\n    content\n    author {\n      id\n      email\n    }\n}\n```\n\nEsto significa que debe haber un esquema de tipo consulta con el nombre \"post\" definido en el servidor. Esta consulta está pidiendo el id, título, contenido, el id del autor y el correo del autor de la publicación con id \"1\". Si es encontrada, la respuesta seguirá la misma estructura descrita en la consulta. Una consulta de GraphQL es análoga a realizar una llamada con GET a un endpoint REST.\n\nUna mutación en GraphQL se ve de la siguiente forma:\n\n```javascript\nmutation {\n  createAccount(\n    email:\"pablo@berganza.dev\"\n    password:\"super secure password\"\n  ) {\n    id\n    email\n  }\n}\n```\n\nEsto asume que hay un esquema de tipo mutación llamado \"createAccount\" definido en el servidor. Esta mutación está pidiéndole al servidor que cree una cuenta con el email y la contraseña especificadas, y al terminar la creación que retorne su id y su email.\n\nGraphQL no debería considerarse un estilo de arquitectura. Es, más bien, una serie de herramientas que facilitan el desarrollo de APIs tipo RPC (ya que estás llamando funciones en el servidor). Aún así, una API GraphQL comparte varias características con un API REST:\n\n  * Hay una clara separación entre cliente y servidor.\n  * El servidor no mantiene un estado.\n  * Aunque la mayoría de APIs GraphQL son servidas sobre HTTP, podría ser servida sobre un protocolo distinto.\n\nA parte de esto, un API GraphQL tiene otras ventajas sobre un API REST:\n\n  * Una interfaz consistente con el cliente, ya que la comunicación cliente-servidor se hace utilizando un lenguage de consulta ya definido.\n  * La documentación es auto-generada. Cuando los esquemas son definidos, estos está disponibles para que el cliente las vea. También es posible agregar \"docstrings\" a los esquemas para poder explicarlos más a fondo.\n  * Las herramientas disponibles proveen una muy agradable experiencia de desarrollo. Herramientas como Graphiql y GraphQL Playground pueden hacer explorar los esquemas de un API GraphQL muy fácil, y muchas librerías para el cliente, como Apollo, pueden proveer otras herramientas para agregar funcionalidad al cliente.\n  * Desde el momento en que los esquemas son definidos hay un contrato entre el cliente y el servidor. Los esquemas incluyen las propiedades y los tipos de datos esperados en entrada y salida. Más propiedades pueden ser agregadas después al esquema, pero no se recomienda remover propiedades que ya están definidas.\n  * La barrera de entrada para diseñar un API GraphQL comparada a un API REST es mucho más baja.\n  * Ya hay una vasta cantidad de implementaciones de la exacta especificación de GraphQL en la mayoría de lenguages de programación grandes, esto permite una interacción consistente entre distintas APIs GraphQL.\n  * Reduce considerablemente la cantidad de llamadas al servidor, ya que toda la información puede ser pedida, potencialmente, con una sola llamada.\n\nPero obviamente no hay solo ventajas en el mundo de GraphQL. Estamos perdiendo algunas de las ventajas proveídas por la arquitectura REST cuando implementamos un API GraphQL, y además hay otras desventajas:\n\n  * Aunque es generalmente servida sobre HTTP, se pierde muchos beneficios proporcionados por dicho protocolo como caching, limitación de peticiones, etc. Esto reduce su escalabilidad potencialmente.\n  * Un API GraphQL es potencialmente menos eficiente que un API REST. Debido a la impredecible complejidad de las llamadas hechas al servidor, es probable que un solo llamado al servidor implique operaciones N+1.\n  * Al ser publicada en el 2015 (y al iniciar desarrollo en el 2012) se puede argumentar que el cosistema todavía no es maduro y hay posibilidad para considerables cambios en el futuro.\n  * Para aplicaciones sencillas las llamadas pueden hacerse utilizando fetch API o librerías como Axios. Pero si la aplicación crece, una librería de GraphQL (como Apollo Client) puede ser necesitada. Esto aumentaría el tamaño del bundle de JavaScript.\n  * Puede aumentar considerablemente la complejidad del código del servidor cuando optimizaciones son requeridas.\n  * GraphQL suele retornar siempre un estado de 200. Como se pueden enviar varias consultas\u002Fmutaciones en un solo llamado, y algunas de estas pueden tener éxito y otras fallar de distinta forma, el manejo de errores puede volverse complicado del lado del cliente.\n\nHay varias otras características en la especificación de GraphQL sobre las que no escribí, como fragments, consultas y mutaciones nombradas, variables, etc. Así que puedes revisar [graphql.org](https:\u002F\u002Fgraphql.org) para aprender más sobre esto si te ha interesado.\n\n## Conclusión\n\nEntonces, ¿vale la pena el cambio? Cómo todo debate entre tecnologías, la respuesta es si y no. Hay casos de uso para ambos, GraphQL y REST. Por ejemplo, una API GraphQL puede ser útil cuando el desarrollo necesita iniciar antes que los requerimientos del cliente estén propiamente definidos, y puede ayudar a mantener un API consistente sin mucho esfuerzo. Al final, siempre se debe evaluar las ventajas y desventajas, y elegir la herramienta adecuada para el trabajo.\n",bodyBegin:13,frontmatter:"title: 'GraphQL: ¿Vale la pena el cambio?'\nintroduction: Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo\ncreated: '2019-06-11'\nbanner: img\u002Fblog-pics\u002F2019-06-11.jpg\nbannertitle: Peloponeso, Grecia\ntags:\n    - graphql\n    - rest\n    - api",path:"\u002FUsers\u002FPabloABC\u002FDocuments\u002FPersonal\u002FJavaScript\u002FSvelte\u002Fpablo.berganza.dev\u002Fmarkdown\u002Fblog\u002F2019-06-11-graphql-is-it-worth-the-switch\u002Findex.es.md",metadata:{title:a,introduction:b,created:c,banner:d,bannertitle:e,tags:[f,g,h]},html:"\u003Cp\u003EEste último año trabajando como desarrollador web he estado, básicamente, respirando \u003Ca href=\"https:\u002F\u002Fes.wikipedia.org\u002Fwiki\u002FTransferencia_de_Estado_Representacional\"\u003EREST\u003C\u002Fa\u003E todos los días. Aunque no es tanto tiempo, ha sido más que suficiente para apreciar la simplicidad sobre SOAP, y para odiar los momentos en que los requerimientos del cliente o otras situaciones te fuerzan a escribir endpoints que no son \u003Ca href=\"https:\u002F\u002Frestfulapi.net\u002Frest-architectural-constraints\u002F\"\u003ERESTful\u003C\u002Fa\u003E. Aunque REST es ya un estándar para crear APIs web modernas, hace un par de años ha habido un competidor del cual no me había forzado a investigar todavía: \u003Ca href=\"https:\u002F\u002Fgraphql.org\"\u003EGraphQL\u003C\u002Fa\u003E. Pero eso ha cambiado y ya he experimentado un poco implementándolo en el cliente y en el servidor.\u003C\u002Fp\u003E\n\u003Cp\u003ESegún \u003Ca href=\"https:\u002F\u002Fgraphql.org\"\u003Egraphql.org\u003C\u002Fa\u003E, &quot;GraphQL es un lenguage de consulta para APIs y un sistema en tiempo de ejecución para cumplir esas consultas con tu información existente&quot;. Un servidor que esté implementando la especificación de GraphQL debería poder recibir una consulta enviada por el cliente, conteniendo una descripción de la infromación específica que el cliente necesita, y debería poder proveer ésta información así como el cliente la pidió.\u003C\u002Fp\u003E\n\u003Cp\u003EPero antes de hablar más sobre GraphQL, veamos qué es tan bueno sobre REST.\u003C\u002Fp\u003E\n\u003Ch2 id=\"rest\"\u003EREST\u003C\u002Fh2\u003E\n\u003Cp\u003EREST es un estilo de arquitectura que define una serie de reglas para construir servicios web. Cuando alguien habla de un API que sigue la arquitectura propuesta por REST, suelen referirse a un servidor que se comunica con el cliente por medio del protocolo HTTP. El cliente se aprovecha de los distintos métodos HTTP (GET, POST, PUT, PATCH, DELETE) para hacer consultas a direcciones en el API que representan recursos.\u003C\u002Fp\u003E\n\u003Cp\u003EAlgunos ejemplos de endpoints REST son:\u003C\u002Fp\u003E\n\u003Cpre class=\"http hljs\"\u003E\u003Ccode\u003EGET http:\u002F\u002Fapi.example.com\u002Faccounts\n\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\u002F8326\n\nGET http:\u002F\u002Fapi.example.com\u002Faccounts\u002F8326\u002Fposts\n\nGET http:\u002F\u002Fapi.example.com\u002Fposts\u002F4123\u002Fcomments\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EDependiendo de qué método se utilice para llamar al endpoint, se aplicará una distinta operación al recursos.\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003EMÉTODO\u003C\u002Fth\u003E\n\u003Cth\u003EENDPOINT\u003C\u002Fth\u003E\n\u003Cth\u003EDESCRIPCIÓN\u003C\u002Fth\u003E\n\u003Cth\u003EESTADO DE RESPUESTA\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003EGET\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u003C\u002Ftd\u003E\n\u003Ctd\u003EObtener una lista de elementos\u003C\u002Ftd\u003E\n\u003Ctd\u003E200\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EGET\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u002F{id}\u003C\u002Ftd\u003E\n\u003Ctd\u003EObtener un solo elemento\u003C\u002Ftd\u003E\n\u003Ctd\u003E200, 404\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EPOST\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u003C\u002Ftd\u003E\n\u003Ctd\u003ECrear un elemento\u003C\u002Ftd\u003E\n\u003Ctd\u003E201, 400\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EPUT\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u002F{id}\u003C\u002Ftd\u003E\n\u003Ctd\u003EModificar un elemento completo\u003C\u002Ftd\u003E\n\u003Ctd\u003E200, 400\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EPATCH\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u002F{id}\u003C\u002Ftd\u003E\n\u003Ctd\u003EModificar campos específicos del elemento\u003C\u002Ftd\u003E\n\u003Ctd\u003E200, 400\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EDELETE\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u002Fresources\u002F{id}\u003C\u002Ftd\u003E\n\u003Ctd\u003EEliminar un elemento\u003C\u002Ftd\u003E\n\u003Ctd\u003E204, 200, 404\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Cp\u003EEsto nos da una limpia y predecible interfaz para operar sobre los recursos en el servidor.\u003C\u002Fp\u003E\n\u003Cp\u003EComo se ve en los endpoints del ejemplo anterior, los endpoints en una arquitectura REST pueden seguir una estructura jerárquica. Por ejemplo, si se hiciera una consulta con el método POST al endpoint \u003Ccode\u003E\u002Faccounts\u002F8326\u002Fposts\u003C\u002Fcode\u003E, ésto debería significar que se está creando una publicación (post) que pertenece a la cuenta (account) con id 8326.\u003C\u002Fp\u003E\n\u003Cp\u003EHe hablado sobre como un API REST debe verse para el cliente, pero éstas características no son suficientes para que una API pueda ser considerada una API REST. Para poder ser clasificada como tal, debe seguir las siguientes seis reglas:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003EInterfaz uniforme\u003C\u002Fstrong\u003E: Una API REST debe tener una interfaz bien definida y consistente. Esta interfaz debe seguirse casi religiosamente en todos los recursos expuestos por el API. Debe tener consistentes convenciones de nombramiento, formato de datos, etc.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ECliente-servidor\u003C\u002Fstrong\u003E: Debe haber una separación clara entre cliente y servidor.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ESin estado\u003C\u002Fstrong\u003E: Todas las interacciones del cliente con el servidor no deben contener estado. Esto significa que el servidor debe asumir que toda consulta hecha a éste es completamente nueva, sin conocimiento alguno de estados anteriores del cliente.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ECacheable\u003C\u002Fstrong\u003E: Si un endpoint REST es suficientemente estable, este podría ser puesto en cache, ya sea en el cliente o servidor. Los endpoints que puedan ser puestos en el cache deben explícitamente indicar esto.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ESistema en capas\u003C\u002Fstrong\u003E: La arquitectura del sistema puede estar en capaz, es decir, el cliente puede estar interactuando con distintos servidores comportándose como que si estuviera interactuando diréctamente con el API REST.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ECódigo a pedido\u003C\u002Fstrong\u003E: Esta es la única regla opcional de la arquitectura REST. Indica que, cuando sea necesario, un endpoint REST puede retornar código ejecutable como respuesta a una consulta del cliente.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EÉstas reglas nos traen varios beneficios:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EUna interfaz uniforme permite que el cliente pueda navegar intuitivamente tu API cuando empiecen a acostumbrarse a este.\u003C\u002Fli\u003E\n\u003Cli\u003EUna interfaz bien definida hace más fácil la organización del código del sevidor en base a recursos.\u003C\u002Fli\u003E\n\u003Cli\u003EUna arquitectura cliente-servidor permite a ambos, el cliente y el servidor, poder evolucionar independientemente.\u003C\u002Fli\u003E\n\u003Cli\u003EAl no mantener estado del cliente un servidor tiene, teóricamente, una escalabilidad ilimitada. Puede replicarse indefinidamente cuando se requieran altos recursos sin afectar la interacción con el cliente.\u003C\u002Fli\u003E\n\u003Cli\u003EMantener un cache de algunos endpoints ayuda a reducir la carga del servidor.\u003C\u002Fli\u003E\n\u003Cli\u003EUn sistema en capas permite al cliente pasar por intermediarios (ej. por motivos de autenticación) mientras sigue interactuando de la misma forma con el servidor.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EAunque el formato de dato más usado en APIs REST es JSON, si es necesario se puede utilizar otros formatos (ej. XML). Además, aunque la mayoría de APIs REST disponibles públicamente son servidas a través del protocolo HTTP, un API REST podría ser servida por un protocolo distinto.\u003C\u002Fp\u003E\n\u003Cp\u003EComo se puede ver, una API REST desarrollada propiamente viene con muchos beneficios, pero también hay unas cuantas desventajas:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003ECómo no hay un estándar único definido sobre como se debe comportar un API REST (además de las seis reglas mencionadas), muchas decisiones del diseño quedan a responsabilidad del desarrollador. Esto significa que no se podrá interactuar necesariamente de la misma forma con dos distintas APIs REST.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EA menos que filtros hayan sido implementados en el servidor, un endpoint REST puede returnar mucha más información de la que el cliente necesita.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EDebido a que los endpoints REST son divididos por recursos, para poder popular completamente una vista del cliente es probable que se necesite hacer varias consultas al servidor.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003ELa consistencia es difícil. El equipo de desarrollo debe tratar activamente de mantener la consistencia, esto significa más esfuerzo a la hora de desarrollar. Es fácil agregar inconsistencias al servidor.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EFechas límite, requerimientos del cliente, etc. pueden llevar a romper algunas de las reglas de REST. Esto podría llevar a una mezcla de distintas arquitecturas (ej. RPC).\u003C\u002Fp\u003E\n\u003Cp\u003EEsto muestra que construir una verdadera API REST no es tarea fácil. Hay varios agujeros en los que el equipo de desarrollo puede caer, haciendo que el resultado final no sea una API REST, y que se pierdan algunos de los beneficios proporcionados por el cumplimiento de las reglas de REST.\u003C\u002Fp\u003E\n\u003Cp\u003EEntonces, ¿qué nos ofrece GraphQL?\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"graphql\"\u003EGraphQL\u003C\u002Fh2\u003E\n\u003Cp\u003EComo se ha dicho antes, GraphQL es descrito como un lenguaje de consultas para APIs. A diferencia de REST, GraphQL define un solo endpoint que acepta toda las operaciones hacia el servidor en un parámetro llamado &quot;query&quot;. Las consultas son generalmente echas utilizando el método POST en el endpoint de GraphQL, pero la especificación permite utilizar el método GET para operaciones de solo lectura.\u003C\u002Fp\u003E\n\u003Cp\u003EHay dos tipos de llamadas que puedes hacer a un API GraphQL: consultas y mutaciones. Una consulta se ve de la siguiente forma:\u003C\u002Fp\u003E\n\u003Cpre class=\"javascript hljs\"\u003E\u003Ccode\u003E{\n  post(id:\u003Cspan class=\"hljs-string\"\u003E\"1\"\u003C\u002Fspan\u003E) {\n    id\n    title\n    content\n    author {\n      id\n      email\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EEsto significa que debe haber un esquema de tipo consulta con el nombre &quot;post&quot; definido en el servidor. Esta consulta está pidiendo el id, título, contenido, el id del autor y el correo del autor de la publicación con id &quot;1&quot;. Si es encontrada, la respuesta seguirá la misma estructura descrita en la consulta. Una consulta de GraphQL es análoga a realizar una llamada con GET a un endpoint REST.\u003C\u002Fp\u003E\n\u003Cp\u003EUna mutación en GraphQL se ve de la siguiente forma:\u003C\u002Fp\u003E\n\u003Cpre class=\"javascript hljs\"\u003E\u003Ccode\u003Emutation {\n  createAccount(\n    email:\u003Cspan class=\"hljs-string\"\u003E\"pablo@berganza.dev\"\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Epassword\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-string\"\u003E\"super secure password\"\u003C\u002Fspan\u003E\n  ) {\n    id\n    email\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EEsto asume que hay un esquema de tipo mutación llamado &quot;createAccount&quot; definido en el servidor. Esta mutación está pidiéndole al servidor que cree una cuenta con el email y la contraseña especificadas, y al terminar la creación que retorne su id y su email.\u003C\u002Fp\u003E\n\u003Cp\u003EGraphQL no debería considerarse un estilo de arquitectura. Es, más bien, una serie de herramientas que facilitan el desarrollo de APIs tipo RPC (ya que estás llamando funciones en el servidor). Aún así, una API GraphQL comparte varias características con un API REST:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EHay una clara separación entre cliente y servidor.\u003C\u002Fli\u003E\n\u003Cli\u003EEl servidor no mantiene un estado.\u003C\u002Fli\u003E\n\u003Cli\u003EAunque la mayoría de APIs GraphQL son servidas sobre HTTP, podría ser servida sobre un protocolo distinto.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EA parte de esto, un API GraphQL tiene otras ventajas sobre un API REST:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EUna interfaz consistente con el cliente, ya que la comunicación cliente-servidor se hace utilizando un lenguage de consulta ya definido.\u003C\u002Fli\u003E\n\u003Cli\u003ELa documentación es auto-generada. Cuando los esquemas son definidos, estos está disponibles para que el cliente las vea. También es posible agregar &quot;docstrings&quot; a los esquemas para poder explicarlos más a fondo.\u003C\u002Fli\u003E\n\u003Cli\u003ELas herramientas disponibles proveen una muy agradable experiencia de desarrollo. Herramientas como Graphiql y GraphQL Playground pueden hacer explorar los esquemas de un API GraphQL muy fácil, y muchas librerías para el cliente, como Apollo, pueden proveer otras herramientas para agregar funcionalidad al cliente.\u003C\u002Fli\u003E\n\u003Cli\u003EDesde el momento en que los esquemas son definidos hay un contrato entre el cliente y el servidor. Los esquemas incluyen las propiedades y los tipos de datos esperados en entrada y salida. Más propiedades pueden ser agregadas después al esquema, pero no se recomienda remover propiedades que ya están definidas.\u003C\u002Fli\u003E\n\u003Cli\u003ELa barrera de entrada para diseñar un API GraphQL comparada a un API REST es mucho más baja.\u003C\u002Fli\u003E\n\u003Cli\u003EYa hay una vasta cantidad de implementaciones de la exacta especificación de GraphQL en la mayoría de lenguages de programación grandes, esto permite una interacción consistente entre distintas APIs GraphQL.\u003C\u002Fli\u003E\n\u003Cli\u003EReduce considerablemente la cantidad de llamadas al servidor, ya que toda la información puede ser pedida, potencialmente, con una sola llamada.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EPero obviamente no hay solo ventajas en el mundo de GraphQL. Estamos perdiendo algunas de las ventajas proveídas por la arquitectura REST cuando implementamos un API GraphQL, y además hay otras desventajas:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAunque es generalmente servida sobre HTTP, se pierde muchos beneficios proporcionados por dicho protocolo como caching, limitación de peticiones, etc. Esto reduce su escalabilidad potencialmente.\u003C\u002Fli\u003E\n\u003Cli\u003EUn API GraphQL es potencialmente menos eficiente que un API REST. Debido a la impredecible complejidad de las llamadas hechas al servidor, es probable que un solo llamado al servidor implique operaciones N+1.\u003C\u002Fli\u003E\n\u003Cli\u003EAl ser publicada en el 2015 (y al iniciar desarrollo en el 2012) se puede argumentar que el cosistema todavía no es maduro y hay posibilidad para considerables cambios en el futuro.\u003C\u002Fli\u003E\n\u003Cli\u003EPara aplicaciones sencillas las llamadas pueden hacerse utilizando fetch API o librerías como Axios. Pero si la aplicación crece, una librería de GraphQL (como Apollo Client) puede ser necesitada. Esto aumentaría el tamaño del bundle de JavaScript.\u003C\u002Fli\u003E\n\u003Cli\u003EPuede aumentar considerablemente la complejidad del código del servidor cuando optimizaciones son requeridas.\u003C\u002Fli\u003E\n\u003Cli\u003EGraphQL suele retornar siempre un estado de 200. Como se pueden enviar varias consultas\u002Fmutaciones en un solo llamado, y algunas de estas pueden tener éxito y otras fallar de distinta forma, el manejo de errores puede volverse complicado del lado del cliente.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EHay varias otras características en la especificación de GraphQL sobre las que no escribí, como fragments, consultas y mutaciones nombradas, variables, etc. Así que puedes revisar \u003Ca href=\"https:\u002F\u002Fgraphql.org\"\u003Egraphql.org\u003C\u002Fa\u003E para aprender más sobre esto si te ha interesado.\u003C\u002Fp\u003E\n\u003Ch2 id=\"conclusión\"\u003EConclusión\u003C\u002Fh2\u003E\n\u003Cp\u003EEntonces, ¿vale la pena el cambio? Cómo todo debate entre tecnologías, la respuesta es si y no. Hay casos de uso para ambos, GraphQL y REST. Por ejemplo, una API GraphQL puede ser útil cuando el desarrollo necesita iniciar antes que los requerimientos del cliente estén propiamente definidos, y puede ayudar a mantener un API consistente sin mucho esfuerzo. Al final, siempre se debe evaluar las ventajas y desventajas, y elegir la herramienta adecuada para el trabajo.\u003C\u002Fp\u003E\n",slug:"2019-06-11-graphql-is-it-worth-the-switch",ttr:12}}}("GraphQL: ¿Vale la pena el cambio?","Una agradable alternativa a APIs REST con una increíble experiencia de desarrollo","2019-06-11","img\u002Fblog-pics\u002F2019-06-11.jpg","Peloponeso, Grecia","graphql","rest","api"))],session:{lang:"es"}};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.e8b9dac7.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.e8b9dac7.js")}document.head.appendChild(s)</script> 