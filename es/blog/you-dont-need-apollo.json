{"attributes":{"title":"En realidad no necesitas Apollo","description":"¿Proyecto hobby? ¿Aprendiendo GraphQL? Tal vez te estás complicando con Apollo","banner":"img/blog-pics/2020-06-08.jpg","bannertitle":"Breslavia, Polonia","tags":["javascript","graphql","react","programacion"],"created":"2020-06-08"},"body":"La primera vez que probé [GraphQL](https://graphql.org) fue cuando todavía me hubiera considerado solamente un desarrollador back-end. Hace aproximadamente dos años me di la oportunidad de aprenderlo gracias al soporte de [NestJS](https://nestjs.com) y me enamoré completamente de él. El hecho de que la documentación se genere automáticamente, y que puedes pedir exactamente la información que necesites con una sola petición, me hizo sentir que trabajar con un API GraphQL como un desarrollador front-end sería muy placentero.\n\n## El camino hacia GraphQL en el front-end\n\nMe había motivado para crear algo del lado del front-end con este nuevo conocimiento. Para ese entonces, todavía estaba acostumbrándome al desarrollo en front-end con [React](https://reactjs.org) (la última vez que había hecho algo en front-end, jQuery seguía siendo la herramienta a utilizar). Naturalmente, busqué `graphql react` en DuckDuckGo y lo primero que encontré fue [Apollo](https://www.apollographql.com). Apollo es una herramienta increíble que ofrece muchas utilidades; incluso puedes manejar el estado de tu aplicación con ella. Pero, esta herramienta si se sentía algo _pesada_ para alguien que solo está intentando aprender como usar GraphQL, o para cualquier proyecto pequeño en ese sentido. Admito que fui algo ingenuo, pero en ese momento si pensé: _wow, GraphQL solamente sería útil para proyectos muy grandes_. Aun así continué realizando mis experimentos con Apollo. Como era de esperar, pasé gran parte del tiempo leyendo como usar Apollo; algo que no es malo en sí, pero si se sentiría abrumador para alguien aprendiendo.\n\nEn algún momento el año pasado encontré [urql](https://formidable.com/open-source/urql/), que busca ser una alternativa más liviana a Apollo, y fue increíble. Un API más simple, y menos utilidades, significaba que requería menos tiempo leyendo la documentación y más tiempo construyendo lo que necesitaba. Pero siempre se sentía algo pesado para mis casos de uso. Aun así, en estos momentos escogería urql sobre Apollo para un proyecto serio, ya que si siento que Apollo intenta hacer demasiado para mi gusto.\n\nActualmente no he trabajado profesionalmente en ningún proyecto que utilice GraphQL, pero he seguido utilizándolo para mis proyectos personales. Sin embargo, durante ese tiempo no podía evitar seguir sintiendo que el punto de entrada era algo alto para cualquier desarrollador front-end que quisiera aprenderlo. Si buscas en DuckDuckGo (o Google) `react graphql`, tus primeros resultados serán Apollo y [howtographql.com](https://www.howtographql.com). Si ingresas a este último, verás que Apollo y urql son listados como la _opción para principiantes_. Siento que esto es un punto de entrada artificialmente alto para un principiante.\n\n## ¿Cuál es la alternativa?\n\n¿Cuáles son los requisitos mínimos para hacer una petición a un API GraphQL desde el navegador? Pues... solamente el API [fetch](https://developer.mozilla.org/es/docs/Web/API/Fetch_API). Después de todo, solo necesitas hacer una petición HTTP POST al endpoint de GraphQL. Esta solo necesita contener una query/mutación en el `body` como una cadena de texto; opcionalmente las variables, si son necesarias para la query. No _necesita_ ser una petición POST, y puede tener un tipo MIME `application/graphql`, pero una petición POST con un tipo MIME `application/json` debería funcionar siempre para mantenerlo sencillo.\n\n```javascript\nfetch(`${API}/graphql`, {\n  method: 'post',\n  headers: { 'content-type': 'application/json' },\n  body: JSON.stringify({\n    query: `...`,\n    variables: {\n      ...\n    },\n  })\n}).then(r => r.json())\n```\n\nPuedes transformar esto en una función más reutilizable así:\n\n```javascript\nasync function gqlFetcher(query, variables) {\n  const { data, errors } = await fetch(`${API}/graphql`, {\n    method: 'post',\n    headers: { 'content-type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n  }).then(r => r.json())\n  if (errors) throw errors\n  return data\n}\n```\n\nUn servidor GraphQL responde con 200 aunque contenga errores. Generalmente solo debes revisar si la respuesta contiene una propiedad `errors`. Esta sigue siendo una manera optimista de manejar la petición, ya que no se está tomando en cuenta otros tipos de errores que sí pueden retornar 4xx o 5xx. Para el objetivo de esta publicación lo dejaremos así.\n\n## Mejor ergonomía\n\nEste método hace que pierdas la cómoda interfaz que Apollo y urql proveen. Siempre puedes crear tus propios hooks que provean una interfaz más amigable, sin embargo, he preferido usar el hook [swr](https://github.com/vercel/swr) de Vercel. Este hook funciona para cualquier petición de datos remotos. Su funcionamiento consiste en retornar primero la data del cache, luego hace la petición, y finalmente retorna la nueva información recibida. Provee una interfaz amigable para manejar la información dentro de tus componentes mientras mantienen tu UI, como ellos mismos lo describen, rápido y reactivo. La función `gqlFetcher` que hicimos antes ya es compatible con el hook `useSWR`, no se requiere trabajo adicional para hacerlo funcionar.\n\n```javascript\nimport useSWR from 'swr'\n\nconst gqlQuery = `...`\n\nfunction Component() {\n  // gqlFetcher es la misma función que se definió antes\n  const { data, error } = useSWR(gqlQuery, gqlFetcher)\n\n  if (error) return <div>{/*...*/}</div> // JSX con la info del error\n  if (!data) return <div>Loading...</div> // Componente de \"Loading\"\n  return <div>{/*...*/}</div> // JSX con la info recibida\n}\n```\n\nPara pasar múltiples argumentos a la función `fetcher`, `useSWR` permite pasar un arreglo como primer argumento.\n\n```javascript\nconst gqlQuery = `...`\nconst gqlVariables = {\n  // ...\n}\n\nfunction Component() {\n  const { data, error } = useSWR([gqlQuery, gqlVariables], gqlFetcher)\n  // ...\n}\n```\n\n> `useSWR` utiliza el primer argumento como una `llave` que sirve para identificar la petición. Si es un arreglo, `swr` compara superficialmente cada elemento y, si alguno de ellos ha cambiado, revalida la petición.\n\n## Herramientas existentes\n\nSi no quieres crear tu propio wrapper sobre `fetch`, puedes usar [graphql-request](https://github.com/prisma-labs/graphql-request). Es un wrapper sobre el API `fetch` para realizar peticiones a un servidor GraphQL que no requiere de mucho trabajo para empezar a utilizarlo. Ya tiene un buen manejo de errores y es isomórfica por defecto (algo que tal vez no le guste a algunas personas). La página de GitHub de `swr` ya muestra un ejemplo con esta herramienta.\n\n```javascript\nimport { request } from 'graphql-request'\n\nconst API = 'https://api.graph.cool/simple/v1/movies'\nconst fetcher = query => request(API, query)\n\nfunction App () {\n  const { data, error } = useSWR(\n    `{\n      Movie(title: \"Inception\") {\n        releaseDate\n        actors {\n          name\n        }\n      }\n    }`,\n    fetcher\n  )\n  // ...\n}\n```\n\n## Conclusión\n\nSiento que hay un punto de entrada artificialmente alto para desarrolladores front-end que quieren entrar al mundo de GraphQL. El hecho de que Apollo y urql sean mostrados como opciones para _principiantes_ puede hacer sentir que estas herramientas son _necesarias_ para trabajar con un API GraphQL. Esto no es cierto. **Sí** puedes construir una aplicación completa utilizando solamente `fetch`, tal vez agregando otras pequeñas librerías para utilidades extras. No puedo imaginar algún proyecto hobby que pueda necesitar todas las utilidades proveídas por estas grandes librerías. Clarificando: no estoy diciendo que no debas usar estas librerías si quieres, sino que no debes sentir que estás librerías son _necesarias_ para construir lo que quieres.\n","bodyBegin":13,"frontmatter":"title: En realidad no necesitas Apollo\ndescription: ¿Proyecto hobby? ¿Aprendiendo GraphQL? Tal vez te estás complicando con Apollo\nbanner: img/blog-pics/2020-06-08.jpg\nbannertitle: Breslavia, Polonia\ntags:\n  - javascript\n  - graphql\n  - react\n  - programacion","path":"/Users/PabloABC/Documents/Personal/JavaScript/Svelte/pablo.berganza.dev/src/markdown/blog/2020-06-08-you-dont-need-apollo/index.es.md","html":"<p>La primera vez que probé <a\n            href=\"https://graphql.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"GraphQL\"\n          >\n            GraphQL\n          </a> fue cuando todavía me hubiera considerado solamente un desarrollador back-end. Hace aproximadamente dos años me di la oportunidad de aprenderlo gracias al soporte de <a\n            href=\"https://nestjs.com\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"NestJS\"\n          >\n            NestJS\n          </a> y me enamoré completamente de él. El hecho de que la documentación se genere automáticamente, y que puedes pedir exactamente la información que necesites con una sola petición, me hizo sentir que trabajar con un API GraphQL como un desarrollador front-end sería muy placentero.</p>\n<h2 id=\"el-camino-hacia-graphql-en-el-front-end\">El camino hacia GraphQL en el front-end</h2>\n<p>Me había motivado para crear algo del lado del front-end con este nuevo conocimiento. Para ese entonces, todavía estaba acostumbrándome al desarrollo en front-end con <a\n            href=\"https://reactjs.org\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"React\"\n          >\n            React\n          </a> (la última vez que había hecho algo en front-end, jQuery seguía siendo la herramienta a utilizar). Naturalmente, busqué <code>graphql react</code> en DuckDuckGo y lo primero que encontré fue <a\n            href=\"https://www.apollographql.com\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"Apollo\"\n          >\n            Apollo\n          </a>. Apollo es una herramienta increíble que ofrece muchas utilidades; incluso puedes manejar el estado de tu aplicación con ella. Pero, esta herramienta si se sentía algo <em>pesada</em> para alguien que solo está intentando aprender como usar GraphQL, o para cualquier proyecto pequeño en ese sentido. Admito que fui algo ingenuo, pero en ese momento si pensé: <em>wow, GraphQL solamente sería útil para proyectos muy grandes</em>. Aun así continué realizando mis experimentos con Apollo. Como era de esperar, pasé gran parte del tiempo leyendo como usar Apollo; algo que no es malo en sí, pero si se sentiría abrumador para alguien aprendiendo.</p>\n<p>En algún momento el año pasado encontré <a\n            href=\"https://formidable.com/open-source/urql/\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"urql\"\n          >\n            urql\n          </a>, que busca ser una alternativa más liviana a Apollo, y fue increíble. Un API más simple, y menos utilidades, significaba que requería menos tiempo leyendo la documentación y más tiempo construyendo lo que necesitaba. Pero siempre se sentía algo pesado para mis casos de uso. Aun así, en estos momentos escogería urql sobre Apollo para un proyecto serio, ya que si siento que Apollo intenta hacer demasiado para mi gusto.</p>\n<p>Actualmente no he trabajado profesionalmente en ningún proyecto que utilice GraphQL, pero he seguido utilizándolo para mis proyectos personales. Sin embargo, durante ese tiempo no podía evitar seguir sintiendo que el punto de entrada era algo alto para cualquier desarrollador front-end que quisiera aprenderlo. Si buscas en DuckDuckGo (o Google) <code>react graphql</code>, tus primeros resultados serán Apollo y <a\n            href=\"https://www.howtographql.com\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"howtographql.com\"\n          >\n            howtographql.com\n          </a>. Si ingresas a este último, verás que Apollo y urql son listados como la <em>opción para principiantes</em>. Siento que esto es un punto de entrada artificialmente alto para un principiante.</p>\n<h2 id=\"¿cuál-es-la-alternativa\">¿Cuál es la alternativa?</h2>\n<p>¿Cuáles son los requisitos mínimos para hacer una petición a un API GraphQL desde el navegador? Pues... solamente el API <a\n            href=\"https://developer.mozilla.org/es/docs/Web/API/Fetch_API\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"fetch\"\n          >\n            fetch\n          </a>. Después de todo, solo necesitas hacer una petición HTTP POST al endpoint de GraphQL. Esta solo necesita contener una query/mutación en el <code>body</code> como una cadena de texto; opcionalmente las variables, si son necesarias para la query. No <em>necesita</em> ser una petición POST, y puede tener un tipo MIME <code>application/graphql</code>, pero una petición POST con un tipo MIME <code>application/json</code> debería funcionar siempre para mantenerlo sencillo.</p>\n<pre class=\"javascript hljs\"><code>fetch(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${API}</span>/graphql`</span>, {\n  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'post'</span>,\n  <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">'content-type'</span>: <span class=\"hljs-string\">'application/json'</span> },\n  <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify({\n    <span class=\"hljs-attr\">query</span>: <span class=\"hljs-string\">`...`</span>,\n    <span class=\"hljs-attr\">variables</span>: {\n      ...\n    },\n  })\n}).then(<span class=\"hljs-function\"><span class=\"hljs-params\">r</span> =&gt;</span> r.json())</code></pre><p>Puedes transformar esto en una función más reutilizable así:</p>\n<pre class=\"javascript hljs\"><code><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">gqlFetcher</span>(<span class=\"hljs-params\">query, variables</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { data, errors } = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${API}</span>/graphql`</span>, {\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">'content-type'</span>: <span class=\"hljs-string\">'application/json'</span> },\n    <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify({ query, variables }),\n  }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">r</span> =&gt;</span> r.json())\n  <span class=\"hljs-keyword\">if</span> (errors) <span class=\"hljs-keyword\">throw</span> errors\n  <span class=\"hljs-keyword\">return</span> data\n}</code></pre><p>Un servidor GraphQL responde con 200 aunque contenga errores. Generalmente solo debes revisar si la respuesta contiene una propiedad <code>errors</code>. Esta sigue siendo una manera optimista de manejar la petición, ya que no se está tomando en cuenta otros tipos de errores que sí pueden retornar 4xx o 5xx. Para el objetivo de esta publicación lo dejaremos así.</p>\n<h2 id=\"mejor-ergonomía\">Mejor ergonomía</h2>\n<p>Este método hace que pierdas la cómoda interfaz que Apollo y urql proveen. Siempre puedes crear tus propios hooks que provean una interfaz más amigable, sin embargo, he preferido usar el hook <a\n            href=\"https://github.com/vercel/swr\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"swr\"\n          >\n            swr\n          </a> de Vercel. Este hook funciona para cualquier petición de datos remotos. Su funcionamiento consiste en retornar primero la data del cache, luego hace la petición, y finalmente retorna la nueva información recibida. Provee una interfaz amigable para manejar la información dentro de tus componentes mientras mantienen tu UI, como ellos mismos lo describen, rápido y reactivo. La función <code>gqlFetcher</code> que hicimos antes ya es compatible con el hook <code>useSWR</code>, no se requiere trabajo adicional para hacerlo funcionar.</p>\n<pre class=\"javascript hljs\"><code><span class=\"hljs-keyword\">import</span> useSWR <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'swr'</span>\n\n<span class=\"hljs-keyword\">const</span> gqlQuery = <span class=\"hljs-string\">`...`</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Component</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// gqlFetcher es la misma función que se definió antes</span>\n  <span class=\"hljs-keyword\">const</span> { data, error } = useSWR(gqlQuery, gqlFetcher)\n\n  <span class=\"hljs-keyword\">if</span> (error) <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{/*...*/}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> <span class=\"hljs-comment\">// JSX con la info del error</span>\n  <span class=\"hljs-keyword\">if</span> (!data) <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> <span class=\"hljs-comment\">// Componente de \"Loading\"</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{/*...*/}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> <span class=\"hljs-comment\">// JSX con la info recibida</span>\n}</code></pre><p>Para pasar múltiples argumentos a la función <code>fetcher</code>, <code>useSWR</code> permite pasar un arreglo como primer argumento.</p>\n<pre class=\"javascript hljs\"><code><span class=\"hljs-keyword\">const</span> gqlQuery = <span class=\"hljs-string\">`...`</span>\n<span class=\"hljs-keyword\">const</span> gqlVariables = {\n  <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Component</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { data, error } = useSWR([gqlQuery, gqlVariables], gqlFetcher)\n  <span class=\"hljs-comment\">// ...</span>\n}</code></pre><blockquote>\n<p><code>useSWR</code> utiliza el primer argumento como una <code>llave</code> que sirve para identificar la petición. Si es un arreglo, <code>swr</code> compara superficialmente cada elemento y, si alguno de ellos ha cambiado, revalida la petición.</p>\n</blockquote>\n<h2 id=\"herramientas-existentes\">Herramientas existentes</h2>\n<p>Si no quieres crear tu propio wrapper sobre <code>fetch</code>, puedes usar <a\n            href=\"https://github.com/prisma-labs/graphql-request\"\n            target=\"_blank\" rel=\"noopener noreferrer\"\n            title=\"graphql-request\"\n          >\n            graphql-request\n          </a>. Es un wrapper sobre el API <code>fetch</code> para realizar peticiones a un servidor GraphQL que no requiere de mucho trabajo para empezar a utilizarlo. Ya tiene un buen manejo de errores y es isomórfica por defecto (algo que tal vez no le guste a algunas personas). La página de GitHub de <code>swr</code> ya muestra un ejemplo con esta herramienta.</p>\n<pre class=\"javascript hljs\"><code><span class=\"hljs-keyword\">import</span> { request } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'graphql-request'</span>\n\n<span class=\"hljs-keyword\">const</span> API = <span class=\"hljs-string\">'https://api.graph.cool/simple/v1/movies'</span>\n<span class=\"hljs-keyword\">const</span> fetcher = <span class=\"hljs-function\"><span class=\"hljs-params\">query</span> =&gt;</span> request(API, query)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { data, error } = useSWR(\n    <span class=\"hljs-string\">`{\n      Movie(title: \"Inception\") {\n        releaseDate\n        actors {\n          name\n        }\n      }\n    }`</span>,\n    fetcher\n  )\n  <span class=\"hljs-comment\">// ...</span>\n}</code></pre><h2 id=\"conclusión\">Conclusión</h2>\n<p>Siento que hay un punto de entrada artificialmente alto para desarrolladores front-end que quieren entrar al mundo de GraphQL. El hecho de que Apollo y urql sean mostrados como opciones para <em>principiantes</em> puede hacer sentir que estas herramientas son <em>necesarias</em> para trabajar con un API GraphQL. Esto no es cierto. <strong>Sí</strong> puedes construir una aplicación completa utilizando solamente <code>fetch</code>, tal vez agregando otras pequeñas librerías para utilidades extras. No puedo imaginar algún proyecto hobby que pueda necesitar todas las utilidades proveídas por estas grandes librerías. Clarificando: no estoy diciendo que no debas usar estas librerías si quieres, sino que no debes sentir que estás librerías son <em>necesarias</em> para construir lo que quieres.</p>\n","ttr":6,"slug":"you-dont-need-apollo"}